<h1 id="chapter-4---vdp-and-display-screen-sections-1-to-5">CHAPTER 4 -
VDP AND DISPLAY SCREEN (Sections 1 to 5)</h1>
<p>The MSX2 machines uses an advanced VDP (video display processor) for
its display screen, the V9938 (MSX-VIDEO). This LSI chip allows for
several new graphics features to be accessed by the MSX2 video display.
It is also fully compatible with the TMS9918A used in the MSX1.</p>
<p>Chapter 4 describes how to use this video display processor. It
describes functions not accessible by BASIC. For mode details
(e.g. hardware specifications), see V9938 MSX-VIDEO Technical Data Book
(ASCII).</p>
<p>
 
</p>
<h2 id="index">Index</h2>
<p><a href="#msx-video-configuration">1. MSX-VIDEO
CONFIGURATION</a></p>
<p><a href="#registers">1.1 Registers</a></p>
<p><a href="#vram">1.2 VRAM</a></p>
<p><a href="#io-ports">1.3 I/O ports</a></p>
<p><a href="#access-to-msx-video">2. ACCESS TO MSX-VIDEO</a></p>
<p><a href="#access-to-registers">2.1 Access to Registers</a></p>
<p><a href="#writing-data-to-control-registers">2.1.1 Writing data
to control registers</a></p>
<p><a href="#setting-a-palette">2.1.2 Setting a palette</a></p>
<p><a href="#reading-status-registers">2.1.3 Reading status
registers</a></p>
<p><a href="#vram-access-from-the-cpu">2.2 VRAM Access From the
CPU</a></p>
<p><a href="#screen-modes-of-the-msx2">3. SCREEN MODES OF THE
MSX2</a></p>
<p><a href="#text-1-mode">3.1 TEXT 1 Mode</a></p>
<p><a href="#setting-text-1-mode">3.1.1 Setting TEXT 1 mode</a></p>
<p><a href="#screen-structure-of-text-1-mode">3.1.2 Screen structure
of TEXT 1 mode</a></p>
<p><a href="#specifying-screen-colour">3.1.3 Specifying screen
colour</a></p>
<p><a href="#text-2-mode">3.2 TEXT 2 Mode</a></p>
<p><a href="#setting-text-2-mode">3.2.1 Setting TEXT 2 mode</a></p>
<p><a href="#screen-structure-of-text-2">3.2.2 Screen structure of
TEXT 2</a></p>
<p><a href="#screen-colour-and-character-blink-specification">3.2.3
Screen colour and character blink specification</a></p>
<p><a href="#multi-colour-mode">3.3 MULTI COLOUR Mode</a></p>
<p><a href="#setting-multi-colour-mode">3.3.1 Setting MULTI COLOUR
mode</a></p>
<p><a
href="#specifying-the-screen-colour-in-multi-colour-mode">3.3.3
Specifying the screen colour in MULTI COLOUR mode</a></p>
<p><a href="#graphic-1-mode">3.4 GRAPHIC 1 Mode</a></p>
<p><a href="#setting-graphic-1-mode">3.4.1 Setting GRAPHIC 1
mode</a></p>
<p><a href="#screen-structure-of-graphic-1-mode">3.4.2 Screen
structure of GRAPHIC 1 mode</a></p>
<p><a href="#specifying-the-screen-colour">3.4.3 Specifying the
screen colour</a></p>
<p><a href="#graphic-2-graphic-3-modes">3.5 GRAPHIC 2, GRAPHIC 3
modes</a></p>
<p><a href="#setting-graphic-2-graphic-3-modes">3.5.1 Setting
GRAPHIC 2, GRAPHIC 3 modes</a></p>
<p><a href="#screen-structure-of-graphic-2-graphic-3-modes">3.5.2
Screen structure of GRAPHIC 2, GRAPHIC 3 modes</a></p>
<p><a href="#screen-colour-specification">3.5.3 Screen colour
specification</a></p>
<p><a href="#graphic-4-mode">3.6 GRAPHIC 4 Mode</a></p>
<p><a href="#setting-graphic-4-mode">3.6.1 Setting GRAPHIC 4
mode</a></p>
<p><a href="#screen-structure-of-graphic-4-mode">3.6.2 Screen
structure of GRAPHIC 4 mode</a></p>
<p><a href="#screen-colour-specification">3.6.3 Screen colour
specification</a></p>
<p><a href="#graphic-5-mode">3.7 GRAPHIC 5 Mode</a></p>
<p><a href="#setting-graphic-5-mode">3.7.1 Setting GRAPHIC 5
mode</a></p>
<p><a href="#pattern-name-table">3.7.2 Pattern name table</a></p>
<p><a href="#setting-the-screen-colour">3.7.3 Setting the screen
colour</a></p>
<p><a href="#graphic-6-mode">3.8 GRAPHIC 6 Mode</a></p>
<p><a href="#setting-graphic-6-mode">3.8.1 Setting GRAPHIC 6
mode</a></p>
<p><a href="#pattern-name-table">3.8.2 Pattern name table</a></p>
<p><a href="#setting-screen-colour">3.8.3 Setting screen
colour</a></p>
<p><a href="#graphic-7-mode-use">3.9 GRAPHIC 7 Mode Use</a></p>
<p><a href="#setting-graphic-7-mode">3.9.1 Setting GRAPHIC 7
mode</a></p>
<p><a href="#pattern-name-table">3.9.2 Pattern name table</a></p>
<p><a href="#setting-the-screen-colour">3.9.3 Setting the screen
colour</a></p>
<p><a href="#miscellaneous-functions-for-the-screen-display">4.
MISCELLANEOUS FUNCTIONS FOR THE SCREEN DISPLAY</a></p>
<p><a href="#sprites">5. SPRITES</a></p>
<p><a href="#sprite-function">5.1 Sprite Function</a></p>
<p><a href="#sprite-mode-1">5.2 Sprite mode 1</a></p>
<p><a href="#number-of-sprites-to-be-displayed">5.2.1 Number of
sprites to be displayed</a></p>
<p><a href="#sprite-display-settings">5.2.2 Sprite display
settings</a></p>
<p><a href="#judging-the-sprite-conflicts">5.2.3 Judging the sprite
conflicts</a></p>
<p><a href="#sprite-mode-2">5.3 Sprite Mode 2</a></p>
<p><a href="#number-of-sprites-to-be-displayed">5.3.1 Number of
sprites to be displayed</a></p>
<p><a href="#sprite-display-settings">5.3.2 Sprite display
settings</a></p>
<p><a href="#judging-sprite-conflicts">5.3.3 Judging sprite
conflicts</a></p>
<p><a href="#changes-from-the-original">Changes from the
original</a></p>
<p>
 
</p>
<h2 id="msx-video-configuration">1. MSX-VIDEO CONFIGURATION</h2>
<p>The following features of the MSX-VIDEO give it a better display
capabilities than the TMS9918A:</p>
<ul>
<li>512 colours with a 9-bit colour palette</li>
<li>Max. 512 x 424 dot resolution (when using the interlace)</li>
<li>Max. 256 colours at the same time</li>
<li>Full bitmap mode which makes graphic operations easy</li>
<li>Text display mode of 80 characters per line</li>
<li>LINE, SEARCH, AREA-MOVE executable by hardware</li>
<li>Up to 8 sprites on the same horizontal line</li>
<li>Different colours can be specified for each line in a sprite</li>
<li>Video signal digitizing feature built-in</li>
<li>Superimpose feature built-in</li>
</ul>
<p>
 
</p>
<h3 id="registers">1.1 Registers</h3>
<p>MSX-VIDEO uses 49 internal registers for its screen operations. These
registers are referred to as “VDP registers” in this book. VDP registers
are classified by function into three groups as described below. The
control register group and status register group can be referred to
using VDP(n) system variables from BASIC.</p>
<p><em>(1) Control register group (R#0 to R#23, R#32 to R#46)</em></p>
<p>This is a read-only 8-bit register group controlling MSX-VIDEO
actions. Registers are expressed using the notation R#n. R#0 to R#23 are
used to set the screen mode. R#32 to R#46 are used to execute VDP
commands. These VDP commands will be described in detail in <a
href="#sprites">section 5</a>. Control registers R#24 to R#31 do not
exist. The roles of the different control registers are listed in <a
href="#table-4.1-control-register-list">Table 4.1</a>.</p>
<h5 id="table-4.1-control-register-list"><em>Table 4.1 Control register
list</em></h5>
<pre><code>-----------------------------------------------------------------------------
|      | Corres- |                                                          |
| R#n  | ponding |                        Function                          |
|      | VDP(n)  |                                                          |
|------+---------+----------------------------------------------------------|
| R#0  | VDP(0)  | mode register #0                                         |
| R#1  | VDP(1)  | mode register #1                                         |
| R#2  | VDP(2)  | pattern name table                                       |
| R#3  | VDP(3)  | colour table (LOW)                                       |
| R#4  | VDP(4)  | pattern generator table                                  |
| R#5  | VDP(5)  | sprite attribute table (LOW)                             |
| R#6  | VDP(6)  | sprite pattern generator table                           |
| R#7  | VDP(7)  | border colour/character colour at text mode              |
| R#8  | VDP(9)  | mode register #2                                         |
| R#9  | VDP(10) | mode register #3                                         |
| R#10 | VDP(11) | colour table (HIGH)                                      |
| R#11 | VDP(12) | sprite attribute table (HIGH)                            |
| R#12 | VDP(13) | character colour at text blinks                          |
| R#13 | VDP(14) | blinking period                                          |
| R#14 | VDP(15) | VRAM access address (HIGH)                               |
| R#15 | VDP(16) | indirect specification of S#n                            |
| R#16 | VDP(17) | indirect specification of P#n                            |
| R#17 | VDP(18) | indirect specification of R#n                            |
| R#18 | VDP(19) | screen location adjustment (ADJUST)                      |
| R#19 | VDP(20) | scanning line number when the interrupt occurs           |
| R#20 | VDP(21) | colour burst signal 1                                    |
| R#21 | VDP(22) | colour burst signal 2                                    |
| R#22 | VDP(23) | colour burst signal 3                                    |
| R#23 | VDP(24) | screen hard scroll                                       |
|      |         |                                                          |
| R#32 | VDP(33) | SX: X-coordinate to be transferred (LOW)                 |
| R#33 | VDP(34) | SX: X-coordinate to be transferred (HIGH)                |
| R#34 | VDP(35) | SY: Y-coordinate to be transferred (LOW)                 |
| R#35 | VDP(36) | SY: Y-coordinate to be transferred (HIGH)                |
| R#36 | VDP(37) | DX: X-coordinate to be transferred to (LOW)              |
| R#37 | VDP(38) | DX: X-coordinate to be transferred to (HIGH)             |
| R#38 | VDP(39) | DY: Y-coordinate to be transferred to (LOW)              |
| R#39 | VDP(40) | DY: Y-coordinate to be transferred to (HIGH)             |
| R#40 | VDP(41) | NX: num. of dots to be transferred in X direction (LOW)  |
| R#41 | VDP(42) | NX: num. of dots to be transferred in X direction (HIGH) |
| R#42 | VDP(43) | NY: num. of dots to be transferred in Y direction (LOW)  |
| R#43 | VDP(44) | NY: num. of dots to be transferred in Y direction (HIGH) |
| R#44 | VDP(45) | CLR: for transferring data to CPU                        |
| R#45 | VDP(46) | ARG: bank switching between VRAM and expanded VRAM       |
| R#46 | VDP(47) | CMR: send VDP command                                    |
-----------------------------------------------------------------------------</code></pre>
<p><em>(2) Status register (S#0 to S#9)</em></p>
<p>This is a read-only 8-bit register group which reads data from
MSX-VIDEO. Registers are expressed using the notation S#n. The functions
of the registers are listed in <a
href="#table-4.2-status-register-list">Table 4.2</a>.</p>
<h5 id="table-4.2-status-register-list"><em>Table 4.2 Status register
list</em></h5>
<pre><code>-----------------------------------------------------------------------------
|      | Corres- |                                                          |
| S#n  | ponding |                        Function                          |
|      | VDP(n)  |                                                          |
|------+---------+----------------------------------------------------------|
| S#0  | VDP(8)  | interrupt information                                    |
| S#1  | VDP(-1) | interrupt information                                    |
| S#2  | VDP(-2) | DP command control information/etc.                      |
| S#3  | VDP(-3) | coordinate detected (LOW)                                |
| S#4  | VDP(-4) | coordinate detected (HIGH)                               |
| S#5  | VDP(-5) | coordinate detected (LOW)                                |
| S#6  | VDP(-6) | coordinate detected (HIGH)                               |
| S#7  | VDP(-7) | data obtained by VDP command                             |
| S#8  | VDP(-8) | X-coordinate obtained by search command (LOW)            |
| S#9  | VDP(-9) | X-coordinate obtained by search command (HIGH)           |
-----------------------------------------------------------------------------</code></pre>
<p><em>(3) Colour palette register group (P#0 to P#15)</em></p>
<p>These registers are used to set the colour palette. Registers are
expressed using the notation P#n where ‘n’ is the palette number which
represents one of 512 colours. Each palette register has 9 bits allowing
three bits to be used for each RGB colour (red, green, and blue).</p>
<p>
 
</p>
<h3 id="vram">1.2 VRAM</h3>
<p>MSX-VIDEO can be connected with 128K bytes VRAM (Video RAM) and 64K
bytes expanded RAM. MSX-VIDEO has a 17-bit counter for accessing this
128K bytes address area. Note that this memory is controlled by
MSX-VIDEO and cannot be directly accessed by the CPU.</p>
<p>Expanded RAM memory cannot be directly displayed to the screen as can
that of VRAM. However, it can be manipulated the same as VRAM when using
the video processor commands. This large work area is very useful when
processing screen data. Note that the MSX standard does not include
instructions regarding expanded RAM, so taking advantage of this in
program design could result in compatibility problems with other MSX
machines.</p>
<h5 id="figure-4.1-vram-and-expanded-ram"><em>Figure 4.1 VRAM and
expanded RAM</em></h5>
<figure>
<img
src="../pics/Figure%204.1.png"
alt="Figure 4.1" />
<figcaption aria-hidden="true">Figure 4.1</figcaption>
</figure>
<p>
 
</p>
<h3 id="io-ports">1.3 I/O ports</h3>
<p>MSX-VIDEO has four I/O ports that send data back and forth the CPU.
The functions of these ports are listed in <a
href="#table-4.3-msx-video-ports">Table 4.3</a>. The ports are accessed
by the CPU through its I/O addresses in the table below, addresses
expressed as n, n’ are stored at address locations 6 and 7 in MAIN-ROM.
Although n = n’ = 98H normally, this can be different on some machines,
so port addresses should be obtained from these addresses for reliable
results.</p>
<p>It is generally recommended that BIOS be used for I/O operations for
purposes of compatibility. However, the screen display often requires
high speed, so these I/O ports are capable of accessing MSX-VIDEO
directly.</p>
<h5 id="table-4.3-msx-video-ports"><em>Table 4.3 MSX-VIDEO
ports</em></h5>
<pre><code>----------------------------------------------------------------------
|      Port       | Address |               Function                 |
|-----------------+---------+----------------------------------------|
| port #0 (READ)  |    n    | read data from VRAM                    |
| port #0 (WRITE) |    n&#39;   | write data to VRAM                     |
| port #1 (READ)  |  n + 1  | read status register                   |
| port #1 (WRITE) |  n&#39;+ 1  | write to control register              |
| port #2 (WRITE) |  n&#39;+ 2  | write to palette register              |
| port #3 (WRITE) |  n&#39;+ 3  | write to indirectly specified register |
----------------------------------------------------------------------</code></pre>
<p><strong>Note:</strong> The value of n should be obtained by referring
to address 6 in MAIN-ROM The value of n’should be obtained by referring
to address 7 in MAIN-ROM</p>
<p>
 
</p>
<h2 id="access-to-msx-video">2. ACCESS TO MSX-VIDEO</h2>
<p>MSX-VIDEO can be accessed directly through the I/O ports without
going through BIOS. This section describes how to do this.</p>
<p>
 
</p>
<h3 id="access-to-registers">2.1 Access to Registers</h3>
<p>
 
</p>
<h4 id="writing-data-to-control-registers">2.1.1 Writing data to control
registers</h4>
<p>The control registers are write-only registers. As described above,
the partial contents of control registers (R#0 to R#23) can be obtained
by referring to VDP(n) from BASIC. This only reads the value which has
been written in the work area of RAM (F3DFH to F3E6H, FFE7H to FFF6H)
used for writing to registers.</p>
<p>There are three ways, described below, to write data to control
registers. Since MSX accesses MSX-VIDEO inside the timer interrupt
routine to examine the occurrence of sprite conflicts, note that access
procedure will not inhibiting the interrupt when the registers are
accessed in the proper way as described below.</p>
<p><em>(1) Direct access</em></p>
<p>The first way is to directly specify the data and where it is to be
written to. <a href="#figure-4.2-direct-access-to-rn">Figure 4.2</a>
illustrates the procedure. The data is first written to port#1 and then
the destination register number is written to port#1 using the five
least significant bits. The most significant bit is set to 1 and the
second bit is set to 0. Thus the value would be 10XXXXXB in binary
notation where XXXXX is the destination register number.</p>
<h5 id="figure-4.2-direct-access-to-rn"><em>Figure 4.2 Direct access to
R#n</em></h5>
<figure>
<img
src="../pics/Figure%204.2.png"
alt="Figure 4.2" />
<figcaption aria-hidden="true">Figure 4.2</figcaption>
</figure>
<p>Port#1 is also used to set VRAM addresses and is described in <a
href="#vram-access-from-the-cpu">section 2.2</a>. The most
significant bit of the second byte sent to this port is the
address/register flag and determines the operation to take place. When
the bit is set to “1”, writing data to a control register as described
here will take place.</p>
<p><em>(2) Indirect Access (non-autoincrement mode)</em></p>
<p>The second way is to write data to the register specified as the
objective register (R#17 contains the objective pointer). To begin with,
store the register number to be accessed in R#17 by direct access. The
most significant bit is set to 1 and the second bit to 0. Thus the value
would be 10XXXXXB in binary notation where XXXXX is the objective
register number. After this is done, data can be written to the
objective register by sending data to port#3. This method is used for
sending data to the same register continuously. An example would be for
the execution of VDP commands.</p>
<h5
id="figure-4.3-indirect-access-to-rn-non-autoincrement-mode"><em>Figure
4.3 Indirect access to R#n (non-autoincrement mode)</em></h5>
<figure>
<img
src="../pics/Figure%204.3.png"
alt="Figure 4.3" />
<figcaption aria-hidden="true">Figure 4.3</figcaption>
</figure>
<p><em>(3) Indirect Access (autoincrement mode)</em></p>
<p>The third way is to write date to the register indicated by R#17.
R#17 is incremented each time data is sent to port#3. To begin with,
store the beginning register number to be accessed in R#17 by direct
access. The two most significant bits are set to 0. Thus the value would
be 00XXXXXB in binary notation where XXXXX is the beginning register
number.</p>
<p>Since this method allows writing data to continuous control registers
effectively, it is useful when several continuous registers are to be
changed at once. One example would be when the screen mode is
changed.</p>
<h5 id="figure-4.4-indirect-access-to-rn-autoincrement-mode"><em>Figure
4.4 Indirect access to R#n (autoincrement mode)</em></h5>
<figure>
<img
src="../pics/Figure%204.4.png"
alt="Figure 4.4" />
<figcaption aria-hidden="true">Figure 4.4</figcaption>
</figure>
<p>
 
</p>
<h4 id="setting-a-palette">2.1.2 Setting a palette</h4>
<p>To set data in the MSX-VIDEO palette registers (P#0 to P#15), specify
the palette register number in the four lowest significant bits of R#16
(color palette pointer), and then send the data to port#2. Since palette
registers have a length of 9 bits, data must be sent twice; red
brightness and blue brightness first, then green brightness. Brightness
is specified in the lower three bits of a four bit segment. Refer to <a
href="#figure-4.5-setting-a-colour-palette-register">Figure 4.5</a> for
details.</p>
<p>After data is sent to port#2 twice, R#16 is automatically
incremented. This feature makes it easy to initialize all the
palettes.</p>
<h5 id="figure-4.5-setting-a-colour-palette-register"><em>Figure 4.5
Setting a colour palette register</em></h5>
<figure>
<img
src="../pics/Figure%204.5.png"
alt="Figure 4.5" />
<figcaption aria-hidden="true">Figure 4.5</figcaption>
</figure>
<p>(*) Since R#16 is incremented at this point, setting next palette can
be done by sending data to port#2 continuously.</p>
<p>
 
</p>
<h4 id="reading-status-registers">2.1.3 Reading status registers</h4>
<p>Status registers are read-only registers. Their contents can be read
from port#1 by setting the status register number in the least
significant four bits of R#15 (status register pointer) as shown in <a
href="#figure-4.6-acessing-status-registers">Figure 4.6</a>. The four
most significant bits are set to 0. Thus the value would be 0000XXXXB in
binary notation where XXXX is the status register number. Interrupts
should be inhibited before the status register is accessed. After the
desired task is completed, R#15 should be set to 0 and the interrupts
released.</p>
<h5 id="figure-4.6-acessing-status-registers"><em>Figure 4.6 Acessing
status registers</em></h5>
<figure>
<img
src="../pics/Figure%204.6.png"
alt="Figure 4.6" />
<figcaption aria-hidden="true">Figure 4.6</figcaption>
</figure>
<p>
 
</p>
<h3 id="vram-access-from-the-cpu">2.2 VRAM Access From the CPU</h3>
<p>When a VRAM address is to be accessed from the CPU, follow the
procedure described below.</p>
<p><em>(1) Bank switching</em></p>
<p>The first 64K bytes of VRAM (00000H to 0FFFFH) and the 64K bytes of
expanded RAM both reside at the same address space as viewed by
MSX-VIDEO. Bank switching is used so that they can both be online at the
same time. Since MSX2 does not to use expanded VRAM, always select the
VRAM bank. Bank switching is controlled by bit 6 of R#45.</p>
<h5 id="figure-4.7-vramexpanded-ram-bank-switching"><em>Figure 4.7
VRAM/expanded RAM bank switching</em></h5>
<figure>
<img
src="../pics/Figure%204.7.png"
alt="Figure 4.7" />
<figcaption aria-hidden="true">Figure 4.7</figcaption>
</figure>
<p><em>(2) Setting the VRAM page (three high order bits)</em></p>
<p>The 17-bit address for accessing the 128K bytes of VRAM is set in the
address counter (A16 to A0). R#14 contains the three high order bits
(A16 to A14). So this register can be viewed as switching between eight
16K byte pages of VRAM.</p>
<h5 id="figure-4.8-setting-the-vram-page-3-high-order-bits"><em>Figure
4.8 Setting the VRAM page (3 high order bits)</em></h5>
<figure>
<img
src="../pics/Figure%204.8.png"
alt="Figure 4.8" />
<figcaption aria-hidden="true">Figure 4.8</figcaption>
</figure>
<p><em>(3) Setting the VRAM address (14 low order bits)</em></p>
<p>The 14 low order bits of the address should be sent to port#1 in two
bytes. <a href="#figure-4.9-setting-14-low-order-bits">Figure 4.9</a>
shows the details. Make sure that the most significant bit of the second
byte sent is set to 0. This sets the address/register flag to address
mode. The second most significant bit sets the read/write flag. 1
signifies writing to VRAM and 2 signifies reading from VRAM.</p>
<h5 id="figure-4.9-setting-14-low-order-bits"><em>Figure 4.9 Setting 14
low order bits</em></h5>
<figure>
<img
src="../pics/Figure%204.9.png"
alt="Figure 4.9" />
<figcaption aria-hidden="true">Figure 4.9</figcaption>
</figure>
<p><em>(4) Reading/writing VRAM</em></p>
<p>After setting the value in the address counter, read or write data
through port#0. The read/write flag is set the same time as A13 to A8 of
the address counter, as described above.</p>
<p>The address counter is automatically incremented each time a byte of
data is read or written to port #0. This feature allows for easy access
of continuous memory in VRAM.</p>
<h5 id="figure-4.10-access-to-vram-through-port0"><em>Figure 4.10 Access
to VRAM through port#0</em></h5>
<figure>
<img
src="../pics/Figure%204.10.png"
alt="Figure 4.10" />
<figcaption aria-hidden="true">Figure 4.10</figcaption>
</figure>
<p>
 
</p>
<h2 id="screen-modes-of-the-msx2">3. SCREEN MODES OF THE MSX2</h2>
<p>The MSX2 has ten different modes as shown in <a
href="#table-4.4-screen-modes-listing-of-msx2">Table 4.4</a>. Six screen
modes marked with **“*“** in the table below (TEXT 2 and GRAPHIC 3 to
GRAPHIC 7) have been introduced for the MSX2. The other modes have been
improved due to the change from TMS9918A to MSX-VIDEO. Fetures of these
ten screen modes and how to use them are described below.</p>
<h5 id="table-4.4-screen-modes-listing-of-msx2"><em>Table 4.4 Screen
modes listing of MSX2</em></h5>
<pre><code>--------------------------------------------------------------------------
|  Mode Name  | SCREEN mode |                 Description                |
|-------------+-------------+--------------------------------------------|
|   TEXT 1    |  SCREEN 0   | 40 characters per line of text, one colour |
|             |  (width=40) | for each character                         |
|-------------+-------------+--------------------------------------------|
| * TEXT 2    |  SCREEN 0   | 80 characters per line of text,            |
|             |  (width=80) | character blinkable selection              |
|-------------+-------------+--------------------------------------------|
| MULTI-COLOR |  SCREEN 3   | pseudo-graphic, one character              |
|             |             | divided into four block                    |
|-------------+-------------+--------------------------------------------|
|   GRAPHIC 1 |  SCREEN 1   | 32 characters per one line of              |
|             |             | text, the COLOURed character available     |
|-------------+-------------+--------------------------------------------|
|   GRAPHIC 2 |  SCREEN 2   | 256 x 192, the colour is                   |
|             |             | specififed for each 8 dots                 |
|-------------+-------------+--------------------------------------------|
| * GRAPHIC 3 |  SCREEN 4   | GRAPHIC 2 which can use sprite             |
|             |             | mode 2                                     |
|-------------+-------------+--------------------------------------------|
| * GRAPHIC 4 |  SCREEN 5   | 256 x 212; 16 colours are                  |
|             |             | available for each dot                     |
|-------------+-------------+--------------------------------------------|
| * GRAPHIC 5 |  SCREEN 6   | 512 x 212; 4 colours are                   |
|             |             | available for each dot                     |
|-------------+-------------+--------------------------------------------|
| * GRAPHIC 6 |  SCREEN 7   | 512 x 212; 16 colours are                  |
|             |             | available for each dot                     |
|-------------+-------------+--------------------------------------------|
| * GRAPHIC 7 |  SCREEN 8   | 256 x 212; 256 colours are                 |
|             |             | available for each dot                     |
--------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h3 id="text-1-mode">3.1 TEXT 1 Mode</h3>
<p>TEXT 1 screen mode has the following features:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               40 (horizontal) x 24 (vertical)                    |
|                       background/character colours can be selected from  |
|                       512 colours                                        |
| character:            256 characters available                           |
|                       character size: 6 (horizontal) x 8 (vertical)      |
| memory requirements:  for character font ... 2048 bytes                  |
|                                              (8 bytes x 256 characters)  |
|                       for display ........... 960 bytes                  |
|                                               (40 characters x 24 lines) |
| BASIC:                compatible with SCREEN 0 (WIDTH 40)                |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-text-1-mode">3.1.1 Setting TEXT 1 mode</h4>
<p>MSX-VIDEO screen modes are set by using 5 bits of R#0 and R#1. <a
href="#figure-4.11-setting-text1-mode">Figure 4.11</a> shows the
details. The 3-bit mask in R#0 is 000B and the 2-bit mask in R#1 is 10B
when using the TEXT 1 mode.</p>
<h5 id="figure-4.11-setting-text1-mode"><em>Figure 4.11 Setting TEXT1
mode</em></h5>
<figure>
<img
src="../pics/Figure%204.11.png"
alt="Figure 4.11" />
<figcaption aria-hidden="true">Figure 4.11</figcaption>
</figure>
<p>
 
</p>
<h4 id="screen-structure-of-text-1-mode">3.1.2 Screen structure of TEXT
1 mode</h4>
<h5 id="pattern-generator-table">Pattern generator table</h5>
<p>The area in which character fonts are stored is called the pattern
generator table. This table is located in VRAM, and, although the font
is defined by using 8 bytes for each character from the top of the
table, the 2 low order bits of each byte representing the right two
columns are not displayed on the screen. Thus, the size of one character
is 6 x 8 pixels. Each character font set contains 256 different
characters numbered from 0 to 255. Use this code to specify which
character should be displayed on the screen.</p>
<p>Specify the location of the pattern generator table in R#4. Note that
the 6 high order bits of the address (A16 to A11) are specified and the
11 low order bits of the address (A10 to A0) are always 0
(“00000000000B”). So the address in which the pattern generator table
can be set always begins at a multiple of 2K bytes from 00000H. This
address can be found using the system variable BASE(2) from BASIC. <a
href="#figure-4.12-structure-of-the-pattern-generator-table">Figure
4.12</a> shows the structure of the pattern generator table.</p>
<h5 id="figure-4.12-structure-of-the-pattern-generator-table"><em>Figure
4.12 Structure of the pattern generator table</em></h5>
<figure>
<img
src="../pics/Figure%204.12.png"
alt="Figure 4.12" />
<figcaption aria-hidden="true">Figure 4.12</figcaption>
</figure>
<h5 id="pattern-name-table">Pattern name table</h5>
<p>The pattern name table stores the characters to be displayed at each
position on the screen. One byte of memory is used for each character to
be displayed. <a
href="#figure-4.13-structure-of-text1-pattern-name-table">Figure
4.13</a> shows the correspondence between memory location and screen
location.</p>
<p>Specify the location of the pattern generator table in R#2. Note that
the 7 high order bits of the address (A16 to A10) are specified and that
the 10 low order bits of the address (A9 to A0) are always 0
(“0000000000B”). So the address in which the name table can be set
always begins at a multiple of 1K bytes from 00000H. This address can be
found by using the system variable BASE(0) from BASIC. <a
href="#figure-4.13-structure-of-text1-pattern-name-table">Figure
4.13</a> shows the structure of the pattern generator table.</p>
<h5 id="figure-4.13-structure-of-text1-pattern-name-table"><em>Figure
4.13 Structure of TEXT1 pattern name table</em></h5>
<figure>
<img
src="../pics/Figure%204.13.png"
alt="Figure 4.13" />
<figcaption aria-hidden="true">Figure 4.13</figcaption>
</figure>
<p>
 
</p>
<h4 id="specifying-screen-colour">3.1.3 Specifying screen colour</h4>
<p>The screen colour is specified by R#7. The background colour is the
palette specified by the 4 low-order bits of R#7; the 4 high-order bits
specify the foreground colour (see <a
href="#figure-4.14-colour-specification-in-text-1">Figure 4.14</a>). A
“0” in the font pattern is displayed in the background colour and a “1”
is displayed in the foreground colour. Note that in TEXT 1 the border
colour of the screen cannot be set and it is the same as the background
colour.</p>
<h5 id="figure-4.14-colour-specification-in-text-1"><em>Figure 4.14
Colour specification in TEXT 1</em></h5>
<figure>
<img
src="../pics/Figure%204.14.png"
alt="Figure 4.14" />
<figcaption aria-hidden="true">Figure 4.14</figcaption>
</figure>
<p>
 
</p>
<h3 id="text-2-mode">3.2 TEXT 2 Mode</h3>
<p>The screen mode TEXT 2 has the following features:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               80 (horizontal) x 24 (vertical) or 26.5 (vertical) |
|                       background colour/character colour can be selected |
|                       from 512 colours                                   |
| character:            256 characters available                           |
|                       character size: 6 (horizontal) x 8 (vertical)      |
|                       each character blinkable                           |
| memory requirements:  24 lines                                           |
|                          for character font ... 2048 bytes               |
|                                               (8 bytes x 256 characters) |
|                          for display .......... 1920 bytes               |
|                                               (80 characters x 24 lines) |
|                          for blinking .........  240 bytes (= 1920 bits) |
|                       26.5 lines                                         |
|                          for character font ... 2048 bytes               |
|                                               (8 bytes x 256 characters) |
|                          for display .......... 2160 bytes               |
|                                               (80 characters x 27 lines) |
|                          for blinking .........  270 bytes (= 2160 bits) |
| BASIC:                compatible with SCREEN 0 (WIDTH 80)                |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-text-2-mode">3.2.1 Setting TEXT 2 mode</h4>
<p>Set TEXT2 mode as shown in <a
href="#figure-4.15-setting-text2-mode">Figure 4.15</a>.</p>
<h5 id="figure-4.15-setting-text2-mode"><em>Figure 4.15 Setting TEXT2
mode</em></h5>
<figure>
<img
src="../pics/Figure%204.15.png"
alt="Figure 4.15" />
<figcaption aria-hidden="true">Figure 4.15</figcaption>
</figure>
<p>
 
</p>
<h5 id="setting-number-of-lines-24-lines26.5-lines">Setting number of
lines (24 lines/26.5 lines)</h5>
<p>TEXT2 mode can switch the screen to 24 lines or 26.5 lines depending
on the value of bit 7 in R#9. Note that, when the screen is set to 26.5
lines, only the upper half of the characters at the bottom of the screen
are displayed. This mode is not supported by BASIC.</p>
<h5 id="figure-4.16-switching-number-of-lines"><em>Figure 4.16 Switching
number of lines</em></h5>
<figure>
<img
src="../pics/Figure%204.16.png"
alt="Figure 4.16" />
<figcaption aria-hidden="true">Figure 4.16</figcaption>
</figure>
<p>
 
</p>
<h4 id="screen-structure-of-text-2">3.2.2 Screen structure of TEXT
2</h4>
<h5 id="pattern-generator-table-1">Pattern generator table</h5>
<p>The pattern generator table has the same structure and function as
the one of TEXT1. See the descriptions for TEXT1.</p>
<h5 id="pattern-name-table-1">Pattern name table</h5>
<p>Since the number of characters to be displayed in the screen has been
increased to 2160 (80 x 27) characters maximum, the maximum area
occupied by the pattern name table is 2160 bytes.</p>
<p>Specify the location of the pattern name table in R#2. The 5 high
order bits of the address (A16 to A12) are specified and the 12 low
order bits of the address (A11 to A0) are always 0 (“000000000000B”). So
the address in which the pattern name table can be set always begins at
a multiple of 4K bytes from 00000H.</p>
<h5 id="figure-4.17-structure-of-text2-pattern-name-table"><em>Figure
4.17 Structure of TEXT2 pattern name table</em></h5>
<figure>
<img
src="../pics/Figure%204.17.png"
alt="Figure 4.17" />
<figcaption aria-hidden="true">Figure 4.17</figcaption>
</figure>
<p>
 
</p>
<h5 id="blink-table">Blink table</h5>
<p>In TEXT2 mode, it is possible to set the blink attribute for each
character. The blink table stores the information of the screen location
of the characters blinked. One bit of the blink table corresponds to one
character on the screen (that is, on the pattern name table). When the
bit is set to “1” blinking is enabled for the corresponding character;
when the bit is “0” blinking is disabled.</p>
<h5 id="figure-4.18-blink-table-structure-of-text2"><em>Figure 4.18
Blink table structure of TEXT2</em></h5>
<figure>
<img
src="../pics/Figure%204.18.png"
alt="Figure 4.18" />
<figcaption aria-hidden="true">Figure 4.18</figcaption>
</figure>
<p>
 
</p>
<p>Specify the starting address of the blink table by setting the 8 high
order bits (A16 to A9) in R#3 and R#10. The location of the blink table
is set by writing the 8 high order bits of the address (A16 to A9) in
R#3 and R#10. The 9 low order bits of the address (A8 to A0) are always
0 (“000000000B”). So the address in which the blink table can be set
always begins at a multiple of 512 bytes from 00000H.</p>
<p>
 
</p>
<h4 id="screen-colour-and-character-blink-specification">3.2.3 Screen
colour and character blink specification</h4>
<p>The foreground colour is specified by the 4 high order bits of R#7
and the background colour by the 4 low order bits of R#7. Characters
with a blink attribute of 1 defined by the blink table alternate between
the blink colour and the colour specified in R#12.</p>
<h5 id="figure-4.19-setting-screen-colour-and-blink-colour"><em>Figure
4.19 Setting screen colour and blink colour</em></h5>
<figure>
<img
src="../pics/Figure%204.19.png"
alt="Figure 4.19" />
<figcaption aria-hidden="true">Figure 4.19</figcaption>
</figure>
<p>
 
</p>
<p>The blinking rate is set in R#13. The 4 high order bits define the
display time in the original colour, and the 4 low order bits define the
display time in the blink colour. The period of time is defined in units
of 1/6 seconds.</p>
<h5 id="figure-4.20-setting-blink-rate"><em>Figure 4.20 Setting blink
rate</em></h5>
<figure>
<img
src="../pics/Figure%204.20.png"
alt="Figure 4.20" />
<figcaption aria-hidden="true">Figure 4.20</figcaption>
</figure>
<p>
 
</p>
<h5 id="list-4.1-blink-example"><em>List 4.1 Blink example</em></h5>
<pre><code>1000 &#39;*********************************************************
1010 &#39;  LIST 4.1  BLINK SAMPLE
1020 &#39;*********************************************************
1030 &#39;
1040 SCREEN 0 : WIDTH 80                &#39;TEXT 2 mode
1050 ADR=BASE(1)                        &#39;TAKE COLOR TABLE ADDRESS
1060 &#39;
1070 FOR I=0 TO 2048/8
1080   VPOKE ADR+I,0                    &#39;reset blink mode
1090 NEXT
1100 &#39;
1110 VDP(7) =&amp;HF1                       &#39;text color=15, back color=1
1120 VDP(13)=&amp;H1F                       &#39;text color=1,  back color=15
1130 VDP(14)=&amp;H22                       &#39;set interval and start blink
1140 &#39;
1150 PRINT &quot;Input any character : &quot;;
1160 &#39;
1170 K$=INPUT$(1)
1180 IF K$&lt;CHR$(28) THEN 1230
1190 IF K$&gt;&quot; &quot; THEN GOSUB 1280
1200 PRINT K$;
1210 GOTO 1170
1220 &#39;
1230 VDP(14)=0                          &#39;stop blink
1240 END
1250 &#39;
1260 &#39;----- set blink mode -----
1270 &#39;
1280 X=POS(0) : Y=CSRLIN
1290 A=(Y*80+X)\8
1300 B=X MOD 8
1310 M=VAL(&quot;&amp;B&quot;+MID$(&quot;000000010000000&quot;,8-B,8))
1320 VPOKE ADR+A,VPEEK(ADR+A) XOR M
1330 RETURN</code></pre>
<p>
 
</p>
<h3 id="multi-colour-mode">3.3 MULTI COLOUR Mode</h3>
<p>The MULTI COLOUR mode is described below:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               64 (horizontal) x 48 (vertical) blocks             |
|                       16 colours from 512 colours can be displayed       |
|                       at the same time                                   |
| block:                block size is 4 (horizontal) x 4 (vertical) dots   |
|                       colour can be specified to each block              |
| memory requirements:  for setting colours ........... 2048 bytes         |
|                       for specifying locations ......  768 bytes         |
| sprite:               sprite mode 1                                      |
| BASIC:                compatible to SCREEN 3                             |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-multi-colour-mode">3.3.1 Setting MULTI COLOUR mode</h4>
<p>Set MULTI COLOUR mode as shown in <a
href="#figure-4.21-setting-multi-colour-mode">Figure 4.21</a>.</p>
<h5 id="figure-4.21-setting-multi-colour-mode"><em>Figure 4.21 Setting
MULTI COLOUR mode</em></h5>
<figure>
<img
src="../pics/Figure%204.21.png"
alt="Figure 4.21" />
<figcaption aria-hidden="true">Figure 4.21</figcaption>
</figure>
<p>
 
</p>
<h5 id="pattern-generator-table-2">Pattern generator table</h5>
<p>In this mode, patterns are constructed as 2 x 2 blocks and one
pattern name corresponds to four patterns. The starting address on this
table is specified in R#4. Since only the 6 high order bits (A16 to A11)
of the address is specified, the pattern generator table can be located
at intervals of 2K bytes from 00000H (see <a
href="#figure-4.22-pattern-generator-table-structure-of-multi-colour">Figure
4.22</a>).</p>
<h5
id="figure-4.22-pattern-generator-table-structure-of-multi-colour"><em>Figure
4.22 Pattern generator table structure of MULTI COLOUR</em></h5>
<figure>
<img
src="../pics/Figure%204.22.png"
alt="Figure 4.22" />
<figcaption aria-hidden="true">Figure 4.22</figcaption>
</figure>
<p>
 
</p>
<ol type="1">
<li>This table is in effect when Y is 0, 4, 8, 12, 16, or 20</li>
<li>This table is in effect when Y is 1, 5, 9, 13, 17, or 21</li>
<li>This table is in effect when Y is 2, 8, 10, 14, 18, or 22</li>
<li>This table is in effect when Y is 3, 7, 11, 15, 19, or 23</li>
</ol>
<h5 id="pattern-name-table-2">Pattern name table</h5>
<p>This is the table for displaying specified patterns at desired
locations on the screen. One of four patterns in a pattern name is
displayed at its Y-coordinate value. BASIC sets the contents of this
table as shown in <a
href="#figure-4.23-setting-basic-pattern-name-table">Figure 4.23</a>.
The starting address of the pattern name table is specified by R#2.
Since only the 7 high order bits of the address (A16 to A10) are
specified, the address at which this table can be set is at increments
of 1K bytes from 00000H (see <a
href="#figure-4.24-pattern-name-table-structure-of-multi-colour-mode">Figure
4.24</a>).</p>
<h5 id="figure-4.23-setting-basic-pattern-name-table"><em>Figure 4.23
Setting BASIC pattern name table</em></h5>
<figure>
<img
src="../pics/Figure%204.23.png"
alt="Figure 4.23" />
<figcaption aria-hidden="true">Figure 4.23</figcaption>
</figure>
<p>
 
</p>
<h5
id="figure-4.24-pattern-name-table-structure-of-multi-colour-mode"><em>Figure
4.24 Pattern name table structure of MULTI COLOUR mode</em></h5>
<figure>
<img
src="../pics/Figure%204.24.png"
alt="Figure 4.24" />
<figcaption aria-hidden="true">Figure 4.24</figcaption>
</figure>
<p>
 
</p>
<h4 id="specifying-the-screen-colour-in-multi-colour-mode">3.3.3
Specifying the screen colour in MULTI COLOUR mode</h4>
<p>The border colour of the screen can be specified by R#7 (see <a
href="#figure-4.25-border-colour-specification">Figure 4.25</a>).</p>
<h5 id="figure-4.25-border-colour-specification"><em>Figure 4.25 Border
colour specification</em></h5>
<figure>
<img
src="../pics/Figure%204.25.png"
alt="Figure 4.25" />
<figcaption aria-hidden="true">Figure 4.25</figcaption>
</figure>
<p>
 
</p>
<h3 id="graphic-1-mode">3.4 GRAPHIC 1 Mode</h3>
<p>GRAPHIC 1 Mode is the screen mode as shown below:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               32 (horizontal) x 24 (vertical) patterns           |
|                       16 from 512 colours can be displayed               |
|                       at the same time                                   |
| pattern:              256 kinds of patterns are available                |
|                       pattern size is 8 (horizontal) x 8 (vertical) dots |
|                       any Figure can be defined for each pattern         |
|                       different colour for each 8 pattern can be set     |
| memory requirements:  for pattern font .............. 2048 bytes         |
|                       for colour table ..............   32 bytes         |
| sprite:               sprite mode 1                                      |
| BASIC:                compatible with SCREEN 1                           |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-graphic-1-mode">3.4.1 Setting GRAPHIC 1 mode</h4>
<p>GRAPHIC 1 mode can be set as shown in <a
href="#figure-4.26-setting-graphic-1-mode">Figure 4.26</a>.</p>
<h5 id="figure-4.26-setting-graphic-1-mode"><em>Figure 4.26 Setting
GRAPHIC 1 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.26.png"
alt="Figure 4.26" />
<figcaption aria-hidden="true">Figure 4.26</figcaption>
</figure>
<p>
 
</p>
<h4 id="screen-structure-of-graphic-1-mode">3.4.2 Screen structure of
GRAPHIC 1 mode</h4>
<h5 id="pattern-generator-table-3">Pattern generator table</h5>
<p>In this mode, 256 kinds of patterns, corresponding to codes 0 to 255,
can be displayed on the screen. Fonts of each pattern are defined in the
pattern generator table (see <a
href="#figure-4.27-pattern-generator-table-of-graphic-1-mode">Figure
4.27</a>). The starting address of the pattern generator table is
specified by R#4. Note that only the 6 high order bits of the address
(A16 to A11) are specified.</p>
<h5
id="figure-4.27-pattern-generator-table-of-graphic-1-mode"><em>Figure
4.27 Pattern generator table of GRAPHIC 1 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.27.png"
alt="Figure 4.27" />
<figcaption aria-hidden="true">Figure 4.27</figcaption>
</figure>
<p>
 
</p>
<h5 id="colour-table">Colour table</h5>
<p>The colour specification for each of the 8 patterns are done by the
colour table. Colours for “0” and “1” of the bit of each pattern can be
specified (see <a
href="#figure-4.28-colour-table-structure-of-graphic-1-mode">Figure
4.28</a>). The starting address of the colour table is specified by R#3
and R#10. Note that only the 11 high order bits of the address (A16 to
A6) are specified.</p>
<h5 id="figure-4.28-colour-table-structure-of-graphic-1-mode"><em>Figure
4.28 Colour table structure of GRAPHIC 1 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.28.png"
alt="Figure 4.28" />
<figcaption aria-hidden="true">Figure 4.28</figcaption>
</figure>
<p>
 
</p>
<h5 id="pattern-name-table-3">Pattern name table</h5>
<p>The size of the pattern name table is 768 bytes and the table
corresponds to the pattern on the screen, one by one (see <a
href="#figure-4.29-pattern-name-table-structure-of-graphic-1-mode">Figure
4.29</a>). The starting address of the pattern name table is specified
by R#2. Note that only the 7 high order bits of the address (A16 to A10)
are specified.</p>
<h5
id="figure-4.29-pattern-name-table-structure-of-graphic-1-mode"><em>Figure
4.29 Pattern name table structure of GRAPHIC 1 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.29.png"
alt="Figure 4.29" />
<figcaption aria-hidden="true">Figure 4.29</figcaption>
</figure>
<p>
 
</p>
<h4 id="specifying-the-screen-colour">3.4.3 Specifying the screen
colour</h4>
<p>The border colour of the screen can be specified by R#7 (see <a
href="#figure-4.30-screen-colour-specification-of-graphic-1-mode">Figure
4.30</a>).</p>
<h5
id="figure-4.30-screen-colour-specification-of-graphic-1-mode"><em>Figure
4.30 Screen colour specification of GRAPHIC 1 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.30.png"
alt="Figure 4.30" />
<figcaption aria-hidden="true">Figure 4.30</figcaption>
</figure>
<p>
 
</p>
<h3 id="graphic-2-graphic-3-modes">3.5 GRAPHIC 2, GRAPHIC 3 modes</h3>
<p>GRAPHIC 2 and GRAPHIC 3 modes are the screen modes as described
below:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               32 (horizontal) x 24 (vertical) patterns           |
|                       16 from 512 colours can be displayed               |
|                       at the same time                                   |
| pattern:              768 kinds of patterns are available                |
|                       pattern size is 8 (horizontal) x 8 (vertical) dots |
|                       any Figure can be defined for each pattern         |
|                       only two colours can be used in horizontal 8 dots  |
| memory requirements:  for pattern font .............. 6144 bytes         |
|                       for colour table .............. 6144 bytes         |
| sprite:               sprite mode 1 for GRAPHIC 2                        |
|                       sprite mode 2 for GRAPHIC 3                        |
| BASIC:                compatible to SCREEN 2 for GRAPHIC 2               |
|                       compatible to SCREEN 4 for GRAPHIC 3               |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-graphic-2-graphic-3-modes">3.5.1 Setting GRAPHIC 2,
GRAPHIC 3 modes</h4>
<p>GRAPHIC 2, and GRAPHIC 3 modes are set as <a
href="#figure-4.31-setting-graphic-2-graphic-3-modes">Figure
4.31</a>.</p>
<h5 id="figure-4.31-setting-graphic-2-graphic-3-modes"><em>Figure 4.31
Setting GRAPHIC 2, GRAPHIC 3 modes</em></h5>
<figure>
<img
src="../pics/Figure%204.31.png"
alt="Figure 4.31" />
<figcaption aria-hidden="true">Figure 4.31</figcaption>
</figure>
<p>
 
</p>
<h4 id="screen-structure-of-graphic-2-graphic-3-modes">3.5.2 Screen
structure of GRAPHIC 2, GRAPHIC 3 modes</h4>
<h5 id="pattern-generator-table-4">Pattern generator table</h5>
<p>In this mode, there are three pattern generator tables which are
compatible with GRAPHIC 1 and 768 patterns can be displayed. It cannot
display patterns which are overlapped on the screen, and operating the
pattern generator table in this case causes the 256 x 192 dot graphics
display to be simulated. The starting address of the pattern generator
table is specified by R#4. Note that only 4 bits of the address (A16 to
A13) are specdified, so the address which can be set is located at
interval steps of 8K bytes from 00000H (see <a
href="#figure-4.32-pattern-generator-table-structure-of-graphic-2-graphic-3">Figure
4.32</a>).</p>
<h5
id="figure-4.32-pattern-generator-table-structure-of-graphic-2-graphic-3"><em>Figure
4.32 Pattern generator table structure of GRAPHIC 2, GRAPHIC 3</em></h5>
<figure>
<img
src="../pics/Figure%204.32.png"
alt="Figure 4.32" />
<figcaption aria-hidden="true">Figure 4.32</figcaption>
</figure>
<p>
 
</p>
<h5 id="colour-table-1">Colour table</h5>
<p>The size of the colour table is the same as that of the pattern
generator table and colours for “0” and “1” bits of each horizontal line
of each pattern can be specified (see <a
href="#figure-4.33-colour-table-structure-of-graphic-2-graphic-3-modes">Figure
4.33</a>). The starting address of the colour table is specified by R#3
and R#10. Note that only the 4 high order bits of the address (A16 to
A13) is specified.</p>
<h5
id="figure-4.33-colour-table-structure-of-graphic-2-graphic-3-modes"><em>Figure
4.33 Colour table structure of GRAPHIC 2, GRAPHIC 3 modes</em></h5>
<figure>
<img
src="../pics/Figure%204.33.png"
alt="Figure 4.33" />
<figcaption aria-hidden="true">Figure 4.33</figcaption>
</figure>
<p>
 
</p>
<h5 id="pattern-name-table-4">Pattern name table</h5>
<p>The pattern name table is divided into three stages - upper, middle,
and lower; each displays the pattern by referring to 256 bytes of the
pattern generator (see <a
href="#figure-4.34-pattern-name-table-for-graphic-modes-2-and-3">Figure
4.34</a>). This method enables each of 768 bytes on the pattern name
table to display a different pattern font.</p>
<h5
id="figure-4.34-pattern-name-table-for-graphic-modes-2-and-3"><em>Figure
4.34 Pattern name table for GRAPHIC modes 2 and 3</em></h5>
<figure>
<img
src="../pics/Figure%204.34.png"
alt="Figure 4.34" />
<figcaption aria-hidden="true">Figure 4.34</figcaption>
</figure>
<p>
 
</p>
<h4 id="screen-colour-specification">3.5.3 Screen colour
specification</h4>
<p>The border colour of the screen can be specified by R#7 (see <a
href="#figure-4.35-screen-colour-specification-of-graphic-2-graphic-3-modes">Figure
4.35</a>).</p>
<h5
id="figure-4.35-screen-colour-specification-of-graphic-2-graphic-3-modes"><em>Figure
4.35 Screen colour specification of GRAPHIC 2, GRAPHIC 3 modes</em></h5>
<figure>
<img
src="../pics/Figure%204.35.png"
alt="Figure 4.35" />
<figcaption aria-hidden="true">Figure 4.35</figcaption>
</figure>
<p>
 
</p>
<h3 id="graphic-4-mode">3.6 GRAPHIC 4 Mode</h3>
<p>GRAPHIC 4 mode is described below:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               256 (horizontal) x 212 (vertical) dots             |
|                       (or, 192 vertical)                                 |
|                       16 colours can be displayed at the same time       |
|                       each of 16 colours can be selected from 512 colours|
| command:              high speed graphic by VDP command available        |
| sprite:               mode 2 sprite function available                   |
| memory requirements:  for 192 dots                                       |
|                         bitmap screen ....... 24K bytes (6000H bytes)    |
|                         (4 bits x 256 x 192)                             |
|                       for 212 dots                                       |
|                         bitmap screen ....... 26.5K bytes (6A00H bytes)  |
|                         (4 bits x 256 x 212)                             |
| BASIC:                compatible to SCREEN 5                             |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-graphic-4-mode">3.6.1 Setting GRAPHIC 4 mode</h4>
<p>Set GRAPHIC 4 mode as shown in <a
href="#figure-4.36-graphic-4-mode-setting">Figure 4.36</a>.</p>
<h5 id="figure-4.36-graphic-4-mode-setting"><em>Figure 4.36 GRAPHIC 4
mode setting</em></h5>
<figure>
<img
src="../pics/Figure%204.36.png"
alt="Figure 4.36" />
<figcaption aria-hidden="true">Figure 4.36</figcaption>
</figure>
<p>
 
</p>
<h4 id="screen-structure-of-graphic-4-mode">3.6.2 Screen structure of
GRAPHIC 4 mode</h4>
<h5 id="pattern-name-table-5">Pattern name table</h5>
<p>In GRAPHIC 4 mode, one byte of the pattern name table corresponds
with 2 dots on the screen. The colour information of each dot is
represented by 4 bits and 16 colours can be specified (see <a
href="#figure-4.37-pattern-name-table-structure-of-graphic-4-mode">Figure
4.37</a>). The starting address of the pattern name table is specified
by R#2. Only the 2 high order bits of the address (A16 to A15) are
specified and the 15 low order bits are considered as “0”. Thus, the
four addresses at which the pattern name can be set are 00000H, 08000H,
10000H, and 18000H.</p>
<h5
id="figure-4.37-pattern-name-table-structure-of-graphic-4-mode"><em>Figure
4.37 Pattern name table structure of GRAPHIC 4 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.37.png"
alt="Figure 4.37" />
<figcaption aria-hidden="true">Figure 4.37</figcaption>
</figure>
<p>
 
</p>
<p>The dot at (X,Y) coordinate on the screen can be accessed by using
Expression 4.1. The program of <a
href="#list-4.2-pset-for-graphic-4-mode-written-in-basic">List 4.2</a>
illustrates the use of <a
href="#expression-4.1-the-expression-for-accessing-the-dot-at-xy-coordinate">Expression
4.1</a>.</p>
<h5
id="expression-4.1-the-expression-for-accessing-the-dot-at-xy-coordinate"><em>Expression
4.1 The expression for accessing the dot at (X,Y) coordinate</em></h5>
<pre><code>    ADR = X/2 + Y * 128 + base address</code></pre>
<p>(The colour of the dot is represented by 4 high order bits in the
case that X is even and by 4 low order bits in the case that X is
odd.)</p>
<h5 id="list-4.2-pset-for-graphic-4-mode-written-in-basic"><em>List 4.2
PSET for GRAPHIC 4 mode written in BASIC</em></h5>
<pre><code>100 &#39;*********************************************
110 &#39;  LIST 4.2   dot access of GRAPHIC 4 mode
120 &#39;*********************************************
130 &#39;
140 SCREEN 5
150 BA=0
160 FOR I=0 TO 255
170   X=I:Y=I\2
180   COL=15
190   GOSUB 1000
200 NEXT
210 END
220 &#39;
1000 &#39;****************************************
1010 &#39;  PSET (X,Y),COL
1020 &#39;   COL:color  BA:graphics Base Address
1030 &#39;****************************************
1040 &#39;
1050 ADR=X\2+Y*128+BA
1060 IF X AND 1 THEN BIT=&amp;HF0:C=COL ELSE BIT=&amp;HF:C=COL*16
1070 D=VPEEK(ADR)
1080 D=(D AND BIT) OR C
1090 VPOKE ADR,D
1100 RETURN</code></pre>
<p>
 
</p>
<h4 id="screen-colour-specification-1">3.6.3 Screen colour
specification</h4>
<p>The border colour of the screen can be specified by R#7 (see <a
href="#figure-4.38-screen-colour-specification-in-graphic-4-mode">Figure
4.38</a>).</p>
<h5
id="figure-4.38-screen-colour-specification-in-graphic-4-mode"><em>Figure
4.38 Screen colour specification in GRAPHIC 4 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.38.png"
alt="Figure 4.38" />
<figcaption aria-hidden="true">Figure 4.38</figcaption>
</figure>
<p>
 
</p>
<h3 id="graphic-5-mode">3.7 GRAPHIC 5 Mode</h3>
<p>GRAPHIC 5 mode is described as follows:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               512 (horizontal) x 212 (vertical) dots             |
|                       (or, 192 vertical)                                 |
|                       4 colours can be displayed at the same time        |
|                       each of 4 colours can be selected from 512 colours |
| command:              graphic command by hardware available              |
| sprite:               mode 2 sprite function available                   |
| memory requirements:  for 192 dots                                       |
|                         bitmap screen ....... 24K bytes (6000H bytes)    |
|                         (2 bits x 512 x 192)                             |
|                       for 212 dots                                       |
|                         bitmap screen ....... 26.5K bytes (6A00H bytes)  |
|                         (2 bits x 512 x 212)                             |
| BASIC:                compatible to SCREEN 6                             |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-graphic-5-mode">3.7.1 Setting GRAPHIC 5 mode</h4>
<p>Set GRAPHIC 5 mode as shown in <a
href="#figure-4.39-graphic-5-mode-setting">Figure 4.39</a>.</p>
<h5 id="figure-4.39-graphic-5-mode-setting"><em>Figure 4.39 GRAPHIC 5
mode setting</em></h5>
<figure>
<img
src="../pics/Figure%204.39.png"
alt="Figure 4.39" />
<figcaption aria-hidden="true">Figure 4.39</figcaption>
</figure>
<p>
 
</p>
<h4 id="pattern-name-table-6">3.7.2 Pattern name table</h4>
<p>In GRAPHIC 5 mode, one byte of the pattern name table corresponds
with 4 dots on the screen. The colour information of each dot is
represented by 2 bits and 4 colours can be specified. As with GRAPHIC 4
mode, the pattern name table is set by writing 2 high order bits of the
address in R#2. The addresses can be set at either 00000H, 08000H,
10000H, or 18000H (see <a
href="#figure-4.40-pattern-name-table-structure-of-graphic-5-mode">Figure
4.40</a>).</p>
<h5
id="figure-4.40-pattern-name-table-structure-of-graphic-5-mode"><em>Figure
4.40 Pattern name table structure of GRAPHIC 5 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.40.png"
alt="Figure 4.40" />
<figcaption aria-hidden="true">Figure 4.40</figcaption>
</figure>
<p>
 
</p>
<p>The dot at (X,Y) coordinate on the screen can be accessed by using
Expression 4.2. The program of <a
href="#list-4.3-pset-for-graphic-5-mode-written-in-basic">List 4.3</a>
confirms <a
href="#expression-4.2-the-expression-for-accessing-the-dot-at-xy-coordinate">Expression
4.2</a>.</p>
<h5
id="expression-4.2-the-expression-for-accessing-the-dot-at-xy-coordinate"><em>Expression
4.2 The expression for accessing the dot at (X,Y) coordinate</em></h5>
<pre><code>    ADR = X/4 + Y * 128 + base address</code></pre>
<p>(The colour of the dot is represented by bit 7 and 6, or 5 and 4, or
3 and 2, or 1 and 0, when X MOD 4 is 0, or 1, or 2, or 3,
respectively.)</p>
<h5 id="list-4.3-pset-for-graphic-5-mode-written-in-basic"><em>List 4.3
PSET for GRAPHIC 5 mode written in BASIC</em></h5>
<pre><code>100 &#39;*********************************************
110 &#39;  LIST 4.3   dot access of GRAPHIC 5 mode
120 &#39;*********************************************
130 &#39;
140 SCREEN 6
150 BA=0
160 FOR I=0 TO 511
170   X=I : Y=I\2
180   COL=3
190   GOSUB 1000
200 NEXT
210 END
220 &#39;
1000 &#39;*******************************************
1010 &#39;  PSET(X,Y)
1020 &#39;   COL:colour  BA:graphic Base Address
1030 &#39;*******************************************
1040 &#39;
1050 ADR=X\4+Y*128+BA
1060 LP=X MOD 4
1070 IF LP=0 THEN BIT=&amp;H3F:C=COL*&amp;H40
1080 IF LP=1 THEN BIT=&amp;HCF:C=COL*&amp;H10
1090 IF LP=2 THEN BIT=&amp;HF3:C=COL*&amp;H4
1100 IF LP=3 THEN BIT=&amp;HFC:C=COL
1110 D=VPEEK(ADR)
1120 D=(D AND BIT) OR C
1130 VPOKE ADR,D
1140 RETURN</code></pre>
<p>
 
</p>
<h4 id="setting-the-screen-colour">3.7.3 Setting the screen colour</h4>
<p>In GRAPHIC 5 mode, hardware tiling is done for the border colour of
the screen and sprites. As with the other modes, these colours are
specified by 4 bits; 2 high order bits of 4 bits represents the dot
colour at even locations, and 2 low order bits for the dot colour at odd
locations (see <a
href="#figure-4.41-screen-colour-specification-in-graphic-5-mode">Figure
4.41</a>).</p>
<h5
id="figure-4.41-screen-colour-specification-in-graphic-5-mode"><em>Figure
4.41 Screen colour specification in GRAPHIC 5 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.41.png"
alt="Figure 4.41" />
<figcaption aria-hidden="true">Figure 4.41</figcaption>
</figure>
<p>
 
</p>
<h3 id="graphic-6-mode">3.8 GRAPHIC 6 Mode</h3>
<p>GRAPHIC 6 mode is described as follows:</p>
<pre><code>-----------------------------------------------------------------------------
| screen:               512 (horizontal) x 212 (vertical) dots              |
|                       (or, 192 vertical)                                  |
|                       16 colours can be displayed at the same time        |
|                       each of 16 colours can be selected from 512 colours |
| command:              graphic command by hardware available               |
| sprite:               mode 2 sprite function available                    |
| memory requirements:  for 192 dots                                        |
|                         bitmap screen ....... 48K bytes (C000H bytes)     |
|                         (4 bits x 512 x 192)                              |
|                       for 212 dots                                        |
|                         bitmap screen ....... 53K bytes (D400H bytes)     |
|                         (4 bits x 512 x 212)                              |
|                       Note that this mode cannot be used at all with      |
|                       64K byte VRAM because of the hardware               |
| BASIC:                compatible to SCREEN 7                              |
-----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-graphic-6-mode">3.8.1 Setting GRAPHIC 6 mode</h4>
<p>Set GRAPHIC 6 mode as shown in <a
href="#figure-4.42-graphic-6-mode-setting">Figure 4.42</a>.</p>
<h5 id="figure-4.42-graphic-6-mode-setting"><em>Figure 4.42 GRAPHIC 6
mode setting</em></h5>
<figure>
<img
src="../pics/Figure%204.42.png"
alt="Figure 4.42" />
<figcaption aria-hidden="true">Figure 4.42</figcaption>
</figure>
<p>
 
</p>
<h4 id="pattern-name-table-7">3.8.2 Pattern name table</h4>
<p>In GRAPHIC 6 mode, one byte of the pattern name table corresponds
with 2 dots on the screen. The colour information of each dot is
represented by 4 bits and 16 colours can be specified (see <a
href="#figure-4.43-pattern-name-table-structure-of-graphic-6-mode">Figure
4.43</a>). The starting address of the pattern name table is set by
writing the high order bit of the address in R#2. The two addresses at
which the pattern name table can be set ae either 00000H or 10000H. The
dot at (X,Y) coordinate on the screen can be accessed by using <a
href="#expression-4.3-the-expression-for-the-access-to-the-dot-at-xy-coordinate">Expression
4.3</a>. The program of <a
href="#list-4.4-pset-for-graphic-6-mode-written-in-basic">List 4.4</a>
illustrates this.</p>
<h5
id="figure-4.43-pattern-name-table-structure-of-graphic-6-mode"><em>Figure
4.43 Pattern name table structure of GRAPHIC 6 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.43.png"
alt="Figure 4.43" />
<figcaption aria-hidden="true">Figure 4.43</figcaption>
</figure>
<p>
 
</p>
<p>The dot at (X,Y) coordinate on the screen can be accessed by using
Expression 4.1. The program of <a
href="#list-4.2-pset-for-graphic-4-mode-written-in-basic">List 4.2</a>
illustrates the use of <a
href="#expression-4.1-the-expression-for-accessing-the-dot-at-xy-coordinate">Expression
4.1</a>.</p>
<h5
id="expression-4.3-the-expression-for-the-access-to-the-dot-at-xy-coordinate"><em>Expression
4.3 The expression for the access to the dot at (X,Y)
coordinate</em></h5>
<pre><code>    ADR = X/2 + Y * 256 + base address</code></pre>
<p>(The colour of the dot is represented by 4 high order bits in the
case that X is even and by 4 low order bits in the case that X is
odd.)</p>
<h5 id="list-4.4-pset-for-graphic-6-mode-written-in-basic"><em>List 4.4
PSET for GRAPHIC 6 mode written in BASIC</em></h5>
<pre><code>100 &#39;*********************************************
110 &#39;  LIST 4.4   dot access of GRAPHIC 6 mode
120 &#39;*********************************************
130 &#39;
140 SCREEN 7
150 BA=0
160 FOR I=0 TO 511
170   X=I: Y=I\2: COL=15: GOSUB 1000
180 NEXT
190 END
200 &#39;
1000 &#39;*************************************************
1010 &#39;  PSET (X,Y)
1020 &#39;   COL:color  BA:graphic Base Address
1030 &#39;*************************************************
1040 &#39;
1050 ADR=X\2+Y*256+BA
1060 IF X AND 1 THEN BIT=&amp;HF: C=COL ELSE BIT=&amp;HF0: C=COL*16
1070 VPOKE ADR,(VPEEK(ADR) AND BIT) OR COL
1080 RETURN</code></pre>
<p>
 
</p>
<h4 id="setting-screen-colour">3.8.3 Setting screen colour</h4>
<p>The border colour of the screen can be specified by R#7 (see <a
href="#figure-4.44-screen-colour-specification-in-graphic-6-mode">Figure
4.44</a>).</p>
<h5
id="figure-4.44-screen-colour-specification-in-graphic-6-mode"><em>Figure
4.44 Screen colour specification in GRAPHIC 6 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.44.png"
alt="Figure 4.44" />
<figcaption aria-hidden="true">Figure 4.44</figcaption>
</figure>
<p>
 
</p>
<h3 id="graphic-7-mode-use">3.9 GRAPHIC 7 Mode Use</h3>
<p>GRAPHIC 7 mode is described as follows:</p>
<pre><code>----------------------------------------------------------------------------
| screen:               256 (horizontal) x 212 (vertical) dots             |
|                       (or, 192 vertical)                                 |
|                       256 colours can be displayed at the same time      |
| command:              graphic command by hardware available              |
| sprite:               mode 2 sprite function available                   |
| memory requirements:  for 192 dots                                       |
|                         bitmap screen ....... 48K bytes (C000H bytes)    |
|                         (8 bits x 256 x 192)                             |
|                       for 212 dots                                       |
|                         bitmap screen ....... 53K bytes (D400H bytes)    |
|                         (8 bits x 256 x 212)                             |
|                       Note that this mode cannot be used with 64K byte   |
|                       VRAM machines, as in the case of GRAPHIC 6         |
| BASIC:                compatible to SCREEN 8                             |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="setting-graphic-7-mode">3.9.1 Setting GRAPHIC 7 mode</h4>
<p>Set GRAPHIC 7 mode as shown in <a
href="#figure-4.45-graphic-4-mode-setting">Figure 4.45</a>.</p>
<h5 id="figure-4.45-graphic-4-mode-setting"><em>Figure 4.45 GRAPHIC 4
mode setting</em></h5>
<figure>
<img
src="../pics/Figure%204.45.png"
alt="Figure 4.45" />
<figcaption aria-hidden="true">Figure 4.45</figcaption>
</figure>
<p>
 
</p>
<h4 id="pattern-name-table-8">3.9.2 Pattern name table</h4>
<p>Configuration of GRAPHIC 7 mode is the simplest of all modes; one dot
on the screen corresponds with one byte in the pattern name table. The
value of one byte written in the table represents 256 kinds of colours.
The starting address of the pattern name table is set by R#2. The two
addresses at which the pattern name table can be set are either 00000H
or 10000H (see <a
href="#figure-4.46-pattern-name-table-structure-of-graphic-7-mode">Figure
4.46</a>).</p>
<p>One byte of data represents the intensity of 3 bits for green, 3 bits
for red, and 2 bits for blue, as shown in <a
href="#figure-4.47-rgb-brightness-information">Figure 4.47</a>. The dot
at (X,Y) coordinate on the screen can be accessed by using <a
href="#expression-4.4-the-expression-for-accessing-to-the-dot-at-xy-coordinate">Expression
4.4</a>.</p>
<h5
id="figure-4.46-pattern-name-table-structure-of-graphic-7-mode"><em>Figure
4.46 Pattern name table structure of GRAPHIC 7 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.46.png"
alt="Figure 4.46" />
<figcaption aria-hidden="true">Figure 4.46</figcaption>
</figure>
<p>
 
</p>
<h5 id="figure-4.47-rgb-brightness-information"><em>Figure 4.47 RGB
brightness information</em></h5>
<figure>
<img
src="../pics/Figure%204.47.png"
alt="Figure 4.47" />
<figcaption aria-hidden="true">Figure 4.47</figcaption>
</figure>
<p>
 
</p>
<h5
id="expression-4.4-the-expression-for-accessing-to-the-dot-at-xy-coordinate"><em>Expression
4.4</em> The expression for accessing to the dot at (X,Y)
coordinate</h5>
<pre><code>    ADR = X + Y * 256 + base address</code></pre>
<p>
 
</p>
<h4 id="setting-the-screen-colour-1">3.9.3 Setting the screen
colour</h4>
<p>The border colour of the screen can be specified by R#7 (see <a
href="#figure-4.48-screen-colour-specification-in-graphic-7-mode">Figure
4.48</a>).</p>
<h5
id="figure-4.48-screen-colour-specification-in-graphic-7-mode"><em>Figure
4.48 Screen colour specification in GRAPHIC 7 mode</em></h5>
<figure>
<img
src="../pics/Figure%204.48.png"
alt="Figure 4.48" />
<figcaption aria-hidden="true">Figure 4.48</figcaption>
</figure>
<p>
 
</p>
<h2 id="miscellaneous-functions-for-the-screen-display">4. MISCELLANEOUS
FUNCTIONS FOR THE SCREEN DISPLAY</h2>
<p>Detailed settings for the screen display are available in MSX-VIDEO.
These include screen ON/OFF and specification of the display location.
These MSX-VIDEO functions are described in this function.</p>
<h3 id="screen-onoff">Screen ON/OFF</h3>
<p>The screen ON/OFF function is controlled by bit 6 of R#1 (see <a
href="#figure-4.49-screen-onoff">Figure 4.49</a>). When set OFF, the
entire screen changes to the colour specified by the 4 low order bits of
R#7 (8 bits in GRAPHIC 7 mode). Drawing with the VDP commands is faster
when the screen is set OFF.</p>
<h5 id="figure-4.49-screen-onoff"><em>Figure 4.49 Screen
ON/OFF</em></h5>
<figure>
<img
src="../pics/Figure%204.49.png"
alt="Figure 4.49" />
<figcaption aria-hidden="true">Figure 4.49</figcaption>
</figure>
<p>
 
</p>
<p>BASIC program lines:</p>
<pre><code>   VDP(1)=VDP(1) AND &amp;B10111111 ⟵ Screen OFF
   VDP(1)=VDP(1) OR  &amp;B01000000 ⟵ Screen ON</code></pre>
<h3 id="adjustment-of-the-display-location-on-the-screen">Adjustment of
the display location on the screen</h3>
<p>R#18 is used for adjusting the display location on the screen (see <a
href="#figure-4.50-adjustment-of-the-screen-display">Figure 4.50</a>).
This corresponds with the “SET ADJUST” instruction of BASIC.</p>
<h5 id="figure-4.50-adjustment-of-the-screen-display"><em>Figure 4.50
Adjustment of the screen display</em></h5>
<figure>
<img
src="../pics/Figure%204.50.png"
alt="Figure 4.50" />
<figcaption aria-hidden="true">Figure 4.50</figcaption>
</figure>
<p>
 
</p>
<h3 id="switching-the-number-of-pixels-in-the-y-direction">Switching the
number of pixels in the Y direction</h3>
<p>The number of dots displayed in the Y direction on the screen can be
switched to either 192 dots or 212 dots by setting bit 7 of R#9 to 0 or
1. This function is only valid for five screen modes, TEXT 2, and
GRAPHIC 4 to GRAPHIC 7 modes. When 212 dots are set in TEXT 2 mode, the
number of text lines is 26.5 (=212/8) and on the 27th line only the
upper halves of characters are displayed.</p>
<h5
id="figure-4.51-switching-the-number-of-dots-in-the-vertical-direction"><em>Figure
4.51 Switching the number of dots in the vertical direction</em></h5>
<figure>
<img
src="../pics/Figure%204.51.png"
alt="Figure 4.51" />
<figcaption aria-hidden="true">Figure 4.51</figcaption>
</figure>
<p>
 
</p>
<p>BASIC program lines:</p>
<pre><code>   VDP(10)=VDP(10) AND &amp;B01111111 ⟵ 192 dots
   VDP(10)=VDP(10) OR  &amp;B10000000 ⟵ 212 dots</code></pre>
<h3 id="switching-the-display-page">Switching the display page</h3>
<p>In GRAPHIC modes 4 to 7, the display pages can be easily switched by
setting the starting address of the pattern name table using R#2. In
fact, the second parameter of the “SET PAGE” BASIC instruction switches
the display page this way.</p>
<h5 id="figure-4.52-switching-pages"><em>Figure 4.52 Switching
pages</em></h5>
<figure>
<img
src="../pics/Figure%204.52.png"
alt="Figure 4.52" />
<figcaption aria-hidden="true">Figure 4.52</figcaption>
</figure>
<p>
 
</p>
<h3 id="automatic-alternate-screen-display">Automatic alternate screen
display</h3>
<p>In GRAPHIC modes 4 to 7, two pages can be displayed alternately by
using the following method. Either page 0 and page 1, or page 2 and page
3 can be displayed alternately.</p>
<p>To begin the alternate display, select the odd-numbered page (1 or 3)
using R#2 and set the screen alternation rate in R#13. The 4 high order
bits of R#13 represent the time for displaying the even page and the 4
low order bits represent the time for displaying the odd page. The time
is set in 1/6 seconds interval. Setting 0 for both time periods causes
only the odd page to be displayed.</p>
<h5
id="figure-4.53-setting-the-rate-of-the-screen-alternation"><em>Figure
4.53 Setting the rate of the screen alternation</em></h5>
<figure>
<img
src="../pics/Figure%204.53.png"
alt="Figure 4.53" />
<figcaption aria-hidden="true">Figure 4.53</figcaption>
</figure>
<p>
 
</p>
<h3 id="setting-the-interlaced-mode">Setting the interlaced mode</h3>
<p>The interlaced mode allows an apparent screen resolution in the Y
direction of double the normal mode. A resolution of up to 424 dots in
the Y direction can be achieved using this mode. This is done by
alternating at high speed the normal screen and a screen whose scanning
lines are offset vertically by half a line. In MSX-VIDEO the interlaced
mode is specified by setting bit 3 of R#9 ro “1”. The two screens are
switched 60 times a second.</p>
<p>When the odd page is selected in GRAPHIC 4 to GRAPHIC 7 screen modes
and the alternate screen display mode is selected, the screen is
normally switched at slow rates specified in units of 1/6 seconds.
However, combinig this function and the interlaced function can make the
number of the vertical dots of the display screen seem double.</p>
<h5 id="figure-4.54-setting-the-interlaced-mode"><em>Figure 4.54 Setting
the interlaced mode</em></h5>
<figure>
<img
src="../pics/Figure%204.54.png"
alt="Figure 4.54" />
<figcaption aria-hidden="true">Figure 4.54</figcaption>
</figure>
<p>
 
</p>
<h5 id="list-4.5-interlaced-mode-example"><em>List 4.5 Interlaced mode
example</em></h5>
<pre><code>1000 &#39;***************************************************
1010 &#39;  [List 4.5] interlace mode
1020 &#39;***************************************************
1030 &#39;
1040 COLOR 15,0,0 : SCREEN 5,,,,,0     &#39;noninterlace mode
1050 &#39;
1060 SET PAGE 0,0 : CLS
1070 LINE (32,0)-(64,120),15,BF
1080 SET PAGE 1,1 : CLS
1090 LINE (192,91)-(224,211),15,BF
1100 &#39;
1110 VDP(10)=VDP(10) OR &amp;B00001100     &#39;interlace mode!!!
1120 &#39;
1130 FOR I=32 TO 192
1140   SET PAGE 1,0
1150   LINE (I,0)-STEP(0,120),0
1160   LINE (I+33,0)-STEP(0,120),15
1170   SET PAGE 1,1
1180   LINE (256-I,91)-STEP(0,120),0
1190   LINE (221-I,91)-STEP(0,120),15
1200 NEXT I
1210 &#39;
1220 VDP(10)=VDP(10) AND &amp;B11110011    &#39;interlace off</code></pre>
<h3 id="vertical-scroll-of-the-screen">Vertical scroll of the
screen</h3>
<p>R#23 is used to set the line at which display begins on the screen.
Changing this register enables vertical scrolling of the screen. Note
that, since the scroll is done every 256 lines, the sprite tables should
be moved to another page. <a
href="#list-4.6-vertical-scroll-example">List 4.6</a> shows an
example.</p>
<h5 id="list-4.6-vertical-scroll-example"><em>List 4.6 Vertical scroll
example</em></h5>
<pre><code>1000 &#39;**************************************************************
1010 &#39;  List 4.6  Hardware scroll
1020 &#39;**************************************************************
1030 &#39;
1040 SCREEN 5,2: COLOR 15,0,0: CLS
1050 COPY (0,0)-(255,43) TO (0,212),,PSET   &#39;erase (212,0)-(255,255)
1060 &#39;
1070 FOR I=1 TO 8: D(I)=VAL(MID$(&quot;00022220&quot;,I,1))-1: NEXT
1080 &#39;
1090 OPEN &quot;GRP:&quot; AS #1
1100 FOR I=0 TO 3
1110   PRESET (64,I*64): PRINT #1,&quot;Hit CURSOR Key&quot;
1120 NEXT
1130 &#39;
1140 J=STICK(0)
1150   P=(P+D(J)) AND &amp;HFF
1160   VDP(24)=P
1170 GOTO 1140</code></pre>
<h3 id="specifying-the-colour-code-0-function">Specifying the colour
code 0 function</h3>
<p>Among the 16 colour codes, only code 0 can be made as a “transparent”
colour (the border colour of the screen can be set transparently), the
colour set in palette P#0. Setting bit 5 of R#8 to “1” disables thsi
function and the colour code 0 changes to the colour defined by the
palette P#0.</p>
<h5 id="figure-4.55-colour-code-0-function"><em>Figure 4.55 Colour code
0 function</em></h5>
<figure>
<img
src="../pics/Figure%204.55.png"
alt="Figure 4.55" />
<figcaption aria-hidden="true">Figure 4.55</figcaption>
</figure>
<p>
 
</p>
<h3 id="generating-interrupts-by-the-scanning-line-location">Generating
interrupts by the scanning line location</h3>
<p>In MSX-VIDEO an interrupt can be generated just after the CRT
finishes displaying a specific scanning line. Set in R#19 the number of
the scanning line at which the interrupt should be generated, and set
bit 4 of R#0 to “1” (see <a
href="#figure-4.56-generating-the-scanning-line-interrupt">Figure
4.56</a>).</p>
<h5 id="figure-4.56-generating-the-scanning-line-interrupt"><em>Figure
4.56 Generating the scanning line interrupt</em></h5>
<figure>
<img
src="../pics/Figure%204.56.png"
alt="Figure 4.56" />
<figcaption aria-hidden="true">Figure 4.56</figcaption>
</figure>
<p>
 
</p>
<p>
 
</p>
<h2 id="sprites">5. SPRITES</h2>
<p>Sprites are used to display movable character patterns of 8 x 8 or 16
x 16 dots on the screen. This function is especially useful in the
programming of games.</p>
<p>The parameters specified are the X and Y coordinates, the character
number, and the colour code. The sprite is displayed by writing this
data to the preset sprite attribute table.</p>
<p>There are two modes for MSX2 sprites. Mode 1 is compatible to the
TMS9918 used in the MSX1 machines. Mode 2 includes several improved
functions and has been implemented on the MSX2. This section summarises
the sprite function and describes the two modes.</p>
<p>
 
</p>
<h3 id="sprite-function">5.1 Sprite Function</h3>
<p>Up to 32 sprites can be displayed on one screen at a time.</p>
<p>Sprites have two sizes, 8 x 8 and 16 x 16 dots. Only one size can be
displayed on the screen at a time. The size of one dot of the sprite is
usually the same as one pixel, but in the case of GRPAHIC5 and 6 modes
(for both, the resolution is 512 x 212) the horizontal size is two
pixels, that is, the absolute size of the sprite is the same in any
mode.</p>
<p>The Sprite mode automatically selected is determined by the screen
mode in use. Shown below are the default settings:</p>
<pre><code>Sprite mode 1 selected: ....... GRAPHIC 1       (SCREEN 1)
                                GRAPHIC 2       (SCREEN 2)
                                MULTI colour    (SCREEN 3)

Sprite mode 2 selected: ....... GRAPHIC 3       (SCREEN 4)
                                GRAPHIC 4       (SCREEN 5)
                                GRAPHIC 5       (SCREEN 6)
                                GRAPHIC 6       (SCREEN 7)
                                GRAPHIC 7       (SCREEN 8)</code></pre>
<p>
 
</p>
<h3 id="sprite-mode-1">5.2 Sprite mode 1</h3>
<p>Sprite mode 1 has the same functions as the sprite mode of MSX1
machines. Thus programs using this mode can also be run on the MSX1.</p>
<p>
 
</p>
<h4 id="number-of-sprites-to-be-displayed">5.2.1 Number of sprites to be
displayed</h4>
<p>There are 32 sprites numbered from 0 to 31. Sprites with the smallest
numbers have the highest priority. When sprites are placed on the same
horizontal line of the screen, up to 4 sprites are placed in their order
priority, and the portions of the 5th sprite or higher which conflict
with the existing four sprites on a given line are not displayed.</p>
<h5
id="figure-4.57-number-of-sprites-to-be-displayed-sprite-mode-1"><em>Figure
4.57 Number of sprites to be displayed (sprite mode 1)</em></h5>
<pre><code>-------------------------------------------------------------------------
|                                                                       |
|            --------     --------            --------                  |
|  --------  |  #2  |     |  #3  |  --------  |  #5  |                  |
|  |  #1  |  |      |     |      |  |  #4  |  :      :   ::::::::       |
|  |      |  --------     --------  |      |  ::::::::   :  #6  :       |
|  --------                         --------             |      |       |
|                                                        --------       |
|                                                                       |
|                                                                       |
|                                                                       |
-------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="sprite-display-settings">5.2.2 Sprite display settings</h4>
<p>The following descriptions are settings to display the sprite.</p>
<h5 id="setting-the-size-of-the-sprite">Setting the size of the
sprite</h5>
<p>8 x 8 dots or 16 x 16 dots can be set (see <a
href="#figure-4.58-setting-the-size-of-the-sprite">Figure 4.58</a>). By
default, 8 x 8 dots is selected.</p>
<h5 id="figure-4.58-setting-the-size-of-the-sprite"><em>Figure 4.58
Setting the size of the sprite</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
R#1     | .  | .  | .  | .  | .  | .  | X  | .  |
        -----------------------------------------
                                        |    0: 8 x 8 dots
                                        +--&gt;
                                             1: 16 x 16 dots

  8 x 8 dots                             16 x 16 dots
-------------- -                ------------------------------  -
|            | ^                |                            |  ^
|            | |                |                            |  |
|            | 8 dots           |                            |  |
|            | |                |                            |  |
|            | V                |                            |  |
-------------- -                |                            | 16 dots
|&lt;- 8 dots -&gt;|                  |                            |  |
                                |                            |  |
                                |                            |  |
                                |                            |  |
                                |                            |  V
                                ------------------------------  -
                                |&lt;---    16 x 16 dots    ---&gt;|</code></pre>
<h5 id="expanding-the-sprite">Expanding the sprite</h5>
<p>Figure 4.59 shows how to select whether one dot of the sprite
corresponds to one dot of the screen or whether it is expanded double in
both the horizontal and vertical directions. By default, the one dot to
one dot size is selected.</p>
<h5 id="figure-4.59-expanding-the-sprite"><em>Figure 4.59 Expanding the
sprite</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
R#1     | .  | .  | .  | .  | .  | .  | .  | X  |
        -----------------------------------------
                                             |    0: normal mode
                                             +--&gt;
                                                  1: expansion mode (2X)</code></pre>
<h5 id="setting-the-sprite-pattern-generator-table">Setting the sprite
pattern generator table</h5>
<p>Sprite patterns are defined in the sprite pattern generator table in
VRAM. Up to 256 sprites can be defined in the case of 8 x 8 dots, and up
to 64 for 16 x 16 dots. Each pattern is numbered from 0 to 255 and is
allocated in VRAM as shown in <a
href="#figure-4.60-structure-of-the-sprite-pattern-generator-table-sprite-mode-1">Figure
4.60</a>. For 16 x 16 dots, four 8 x 8 patterns are used from the top of
the table. In this case, using any number of these four patterns causes
the same sprite to be specified. R#6 is used to set the address in the
sprite pattern generator table as shown in <a
href="#figure-4.60-structure-of-the-sprite-pattern-generator-table-sprite-mode-1">Figure
4.60</a>.</p>
<h5
id="figure-4.60-structure-of-the-sprite-pattern-generator-table-sprite-mode-1"><em>Figure
4.60 Structure of the sprite pattern generator table (sprite mode
1)</em></h5>
<pre><code>            VRAM

      |&lt;-- 1 byte  --&gt;|
  -   ----------------- ---+  &lt;--- R#6
  ^   |               |    |       -----------------------------------------
  |   |               |    |       |  0 |  0 | A16| A15| A14| A13| A12| A11|
  |   |               |    |       -----------------------------------------
  8   |               | Pattern
bytes |               |   #0
  |   |               |    |
  |   |               |    |
  V   |               |    |
  -   |---------------| ---+
      |               |    |
      |               |    |
      |               |    |
      |               | Pattern
      |               |   #1
      |               |    |
      |               |    |
      |               |    |
      |---------------| ---+
      |       .       |
              .
              .
      |               |
      |---------------| Pattern #255
      |               |</code></pre>
<h5 id="setting-the-sprite-attribute-table">Setting the sprite attribute
table</h5>
<p>Each sprite is displayed in one of 32 “sprite planes” exclusively,
and the sprite status for each sprite plane is recorded using 4 bytes.
The area having the information for each sprite plane is called the
sprite attribute table. The starting address in VRAM for this table is
set in R#5 and R#11 as shown in <a
href="#figure-4.61-structure-of-the-sprite-attribute-table-sprite-mode-1">Figure
4.61</a>.</p>
<p>The four bytes in the attribute table contain the following
information:</p>
<ul>
<li><strong>Y-coordinate:</strong> specifies Y-coordinate of the sprite.
Note that the top line of the screen is not 0 but 255. Setting this
value in 208 (D0H) causes sprites after this plane not to be
displayed.</li>
<li><strong>X-coordinate:</strong> specifies X-coordinate of the
sprite.</li>
<li><strong>pattern number:</strong> specifies the character in the
sprite pattern generator table to be displayed.</li>
<li><strong>colour code:</strong> specifies the colour (palette number)
of the portion where the bit of the sprite pattern is “1”. *
<strong>EC:</strong> Setting “1” to this bit causes the sprite to be
shifted for 32 bits to the left. Using this function enables the dot of
the sprite to be displayed one by one from the left edge of the
screen.</li>
</ul>
<h5
id="figure-4.61-structure-of-the-sprite-attribute-table-sprite-mode-1"><em>Figure
4.61 Structure of the sprite attribute table (sprite mode 1)</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
    -   ----------------------------------------- --+  ⟵ (*)
    ^   |    :   Y coordinate (0 to 255)   :    |   |
    |   |----+----+----+----+----+----+----+----|   |
    |   |    :   X coordinate (0 to 255)   :    |   |
4 bytes |----+----+----+----+----+----+----+----| Sprite #0 attribute area
    |   |    :  Pattern number (0 to 255)  :    |   |
    |   |----+----+----+----+----+----+----+----|   |
    V   | EC | 0  | 0  | 0  |    Colour code    |   |
    -   |----+----+----+----+----+----+----+----| --+
        |                                       |   |
        |                                       |   | Sprite #1 attribute area
                            .                       .
                            .                       .
                            .                       .

        |                                       |   | Sprite #31 attribute area
        |                                       |   |
        ----------------------------------------- --+

             -----------------------------------------
(*)  R#5     | A14| A13| A12| A11| A10| 1  | 1  | 1  |
             -----------------------------------------
             -----------------------------------------
     R#11    | 0  | 0  | 0  | 0  | 0  | 0  | A16| A15|
             -----------------------------------------


    -------------------------------------------
    |                                         |
    |    ---------------------------------    |
    |    |                               |    |
    |    |               |            ###|:   |
    |    |               |               |    |
    |    |               |             ##|::  |
    |    |               |               |    |     EC bit = &quot;0&quot;
    |    |               V              #|::: |
    |    |                               |    |
    |    |####                           |    |
    |    |  ^                            |    |
    |    ---+-----------------------------    |
    |       |                                 |
    --------+----------------------------------
            |
The sprite will display from here (X coordinate = 0)


    -------------------------------------------
    |                                         |
    |    ---------------------------------    |
    |    |                               |    |
    | :::|#              |               |    |
    |    |               |               |    |
    |  ::|##             |               |    |
    |    |               |               |    |     EC bit = &quot;1&quot;
    |   :|###            V               |    |
    |    |                               |    |
    |    |####                       ####|    |
    |    |                            ^  |    |
    |    -----------------------------+---    |
    |                                 |       |
    ----------------------------------+--------
                                      |
The sprite will display until here (X coordinate = 255)</code></pre>
<p>
 
</p>
<h4 id="judging-the-sprite-conflicts">5.2.3 Judging the sprite
conflicts</h4>
<p>When two sprites conflict, bit 5 of S#0 becomes “1” to inform of the
conflict. A “conflict” means that bits “1” in the sprite pattern whose
colour is not “transparent” occupy the same coordinate (see <a
href="#figure-4.62-conflict-of-sprites-sprite-mode-1">Figure
4.62</a>)</p>
<h5 id="figure-4.62-conflict-of-sprites-sprite-mode-1"><em>Figure 4.62
Conflict of sprites (sprite mode 1)</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
S#0     | .  | .  | X  | .  | .  | .  | .  | .  |
        -----------------------------------------
                    |    0: Normal
                    +--&gt;
                         1: A sprite conflict exists


    +-- ---------------------                     ---------------------
    |   | \\\\\\\ |         |                     | \\\\\\\ |         |
    |   | \\\\\\\ |         | &lt;--- Sprite 1 ---&gt;  | \\ -----+---------+-----
8 or 16 | \\\\\\\ |         |                     | \\ | xx | // |    |    |
 dots   |---------+---------+----------           |----+----- // |    |    |
    |   |         | /////// |         |           |    | /////// |    |    |
    |   |         | /////// |         |           |    |----------    |    |
    |   |         | /////// |         |           |    |              |    |
    +-- ----------+----------         |           -----+---------------    |
                  |                   | &lt;- Sprite 2 -&gt; |                   |
                  |                   |                ---------------------
                  |                   |
                  ---------------------

        These two sprites do not conflict         These two sprites conflict

------  ------
| \\ |  | // | --&gt; This pattern bit has one part
------  ------</code></pre>
<p>When more than 5 sprites are placed on the same line, bit 6 of S#0
becomes “1” and the identifying number of the 5th sprite (the portion
which cannot be displayed) is set in the 5 low order bits of S#0.</p>
<h5 id="figure-4.63-judging-the-conflict-sprite-mode-1"><em>Figure 4.63
Judging the conflict (sprite mode 1)</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
S#0     | .  | X  | .  | X  | X  | X  | X  | X  |
        -----------------------------------------
               |       |                        |
               |       +------------------------+
               |   Identification number of fifth sprite on a single line
               |
               |    0: Normal
               +--&gt;
                    1: More than 4 sprites are occupying a single line</code></pre>
<p>
 
</p>
<h3 id="sprite-mode-2">5.3 Sprite Mode 2</h3>
<p>Sprite mode 2 is the newly added mode for MSX-VIDEO. It is not
compatible with TMS9918 and cannot be used with MSX1 machines.</p>
<p>
 
</p>
<h4 id="number-of-sprites-to-be-displayed-1">5.3.1 Number of sprites to
be displayed</h4>
<p>The number of sprites which can be displayed on one screen is also
32, but up to eight sprites can be displayed on a given horizontal line
of the screen. The priorities are the same as in mode 1 with the lower
numbers having highest priority.</p>
<h5
id="figure-4.64-number-of-sprites-to-be-displayed-sprite-mode-2"><em>Figure
4.64 Number of sprites to be displayed (sprite mode 2)</em></h5>
<pre><code>----------------------------------------------------------------------------
|                                                                          |
|                                                                          |
|  -------           -------------  -------              -------           |
|  |  #0 |  -------  |  #2 |  #4 |  |  #5 |              |  #8 |           |
|  |     |  |  #1 |  |     |---  |  |     |---  -------  :     :  :::::::  |
|  -------  |     |  -------  |---  -------  |  |  #7 |  :::::::  :  #9 :  |
|           -------     |  #3 |        |  #6 |  |     |           |     |  |
|                       -------        -------  -------           -------  |
|                                                                          |
|                                                                          |
----------------------------------------------------------------------------</code></pre>
<p>
 
</p>
<h4 id="sprite-display-settings-1">5.3.2 Sprite display settings</h4>
<h5 id="sprite-size">Sprite size</h5>
<p>Same as sprite mode 1</p>
<h5 id="expanding-sprite">Expanding sprite</h5>
<p>Same as sprite mode 1</p>
<h5 id="sprite-display-onoff">Sprite display ON/OFF</h5>
<p>In sprite mode 2, the sprite display can be turned ON/OFF by bit 1 of
R#8. When this bit is set to 1, no sprites will appear on the
screen.</p>
<h5 id="figure-4.65-sprite-display-specification"><em>Figure 4.65 Sprite
display specification</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
R#8     | .  | .  | .  | .  | .  | .  | X  | .  |
        -----------------------------------------
                                        |    0: Sprite mode on
                                        +--&gt;
                                             1: Sprite mode off</code></pre>
<h5 id="setting-the-pattern-generator-table">Setting the pattern
generator table</h5>
<p>Same as sprite mode 1</p>
<h5 id="sprite-attribute-table">Sprite attribute table</h5>
<p>In sprite mode 2, since different colours can be set for each
horizontal line of the sprite, the colour information is stored in a
sprite colour table as described below, which is independent of the
sprite attribute table. Three kinds of information are stored in the
sprite attribute table (see <a
href="#figure-4.66-structure-of-the-sprite-attribute-table-sprite-mode-2">Figure
4.66</a>).</p>
<ul>
<li><strong>Y-coordinate:</strong> setting this value to 216 (D8H)
causes sprites after this sprite plane not to be displayed. Except for
this, it is the same as the sprite mode 1.</li>
<li><strong>X-coordinate:</strong> same as sprite mode 1.</li>
<li><strong>pattern number:</strong> same as sprite mode 1.</li>
</ul>
<h5
id="figure-4.66-structure-of-the-sprite-attribute-table-sprite-mode-2"><em>Figure
4.66 Structure of the sprite attribute table (sprite mode 2)</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
    -   ----------------------------------------- --+  ⟵ (*)
    ^   |    :   Y coordinate (0 to 255)   :    |   |
    |   |----+----+----+----+----+----+----+----|   |
    |   |    :   X coordinate (0 to 255)   :    |   |
4 bytes |----+----+----+----+----+----+----+----| Sprite #0 attribute area
    |   |    :  Pattern number (0 to 255)  :    |   |
    |   |----+----+----+----+----+----+----+----|   |
    V   |    :    :    :  unused :    :    :    |   |
    -   |----+----+----+----+----+----+----+----| --+
        |                                       |   |
        |                                       |   | Sprite #1 attribute area
                            .                       .
                            .                       .
                            .                       .

        |                                       |   | Sprite #31 attribute area
        |                                       |   |
        ----------------------------------------- --+

             -----------------------------------------
(*)  R#5     | A14| A13| A12| A11| A10| 1  | 1  | 1  |
             -----------------------------------------
             -----------------------------------------
     R#11    | 0  | 0  | 0  | 0  | 0  | 0  | A16| A15|
             -----------------------------------------</code></pre>
<h5 id="sprite-colour-table">Sprite colour table</h5>
<p>The colour table is automatically set at the address 512 bytes before
the starting address of the sprite attribute table. 16 bytes are
allocated for each sprite plane and the following settings are made for
each line of the sprite.</p>
<ul>
<li><strong>colour code:</strong> colour can be specified for each
line.</li>
<li><strong>EC:</strong> the same as EC bit of the attribute table of
sprite mode one. When “1”, the sprite display location is shifted 32
bits to the left. This also can be specified for each line.</li>
<li><strong>CC:</strong> when CC bit is “1”, it can have the same
priority as the sprite “that has the higher priority than this sprite
and whose CC bit is”0” and that is nearest to this sprite plane”. When
sprites having the same priority are overlapped, the colour for which OR
(logical or) of both colour codes are displayed. In this case, the
overlapping does not cause a conflict (see <a
href="#figure-4.68-cc-bit-detection">Figure 4.68</a>).</li>
<li><strong>IC:</strong> (one line of) the sprite with this bit “1” does
not conflict with other sprites.</li>
</ul>
<h5
id="figure-4.67-structure-of-the-sprite-colour-table-sprite-mode-2"><em>Figure
4.67 Structure of the sprite colour table (sprite mode 2)</em></h5>
<pre><code>  MSB   7    6    5    4    3    2    1    0    LSB
      -----------------------------------------            --+ ⟵ starting address of the
   0  | EC | CC | IC | 0  |    Color  code    |  1st line    |    sprite colour table
      |----+----+----+----+----+----+----+----|              |
   1  | EC | CC | IC | 0  |    Color  code    |  2nd line    |
      |----+----+----+----+----+----+----+----|              |
      |                   .                   |              |
                          .                                  |
                          .                                  | Sprite #0 colour table
      |                                       |              |
      |----+----+----+----+----+----+----+----|              |
  15  | EC | CC | IC | 0  |    Color  code    |  16th line   |
      |----+----+----+----+----+----+----+----|            --+
      |                   .                   |            .
                          .                                .
                          .                                .
      |                                       |
      |----+----+----+----+----+----+----+----|            --+
 496  | EC | CC | IC | 0  |    Color  code    |  1th line    |
      |----+----+----+----+----+----+----+----|              |
 497  | EC | CC | IC | 0  |    Color  code    |  2nd line    | Sprite #31 colour table
      |----+----+----+----+----+----+----+----|              |
      |                   .                   |              |
                          .                                  |
                          .                                  |
      |                                       |              |
      |----+----+----+----+----+----+----+----|              |
 511  | EC | CC | IC | 0  |    Color  code    |  16th line   |    starting address of the
      -----------------------------------------            --+ ⟵ sprite attribute table
        |    |    |       |                   |
        |    |    |       +-------------------+
        |    |    |        Specify the colour code (0 to 15)
        |    |    |        for the sprite by each line
        |    |    |                                      1 = no
        |    |    +-------------------&gt; detect conflict: 0 = yed
        |    |
        |    +------------------------&gt; priority: 0 = yes
        |                                         1 = no
        |
        +-----------------------------&gt; 32 dot left shifted display: 1 = yes
                                                                     0 = no</code></pre>
<h5 id="figure-4.68-cc-bit-detection"><em>Figure 4.68 CC bit
detection</em></h5>
<pre><code>     Sprite 1                    Sprite 2             Sprite 1,2 (overlapped)
-------------------         -------------------         -------------------
| ////////// |    |         | \\ |            |         | xx | ///// |    |
| ////////// |    |         | \\ |            |         | xx | ///// |    |
| ////////// |    |         | \\ -------------|         | xx --------+----|
| ////////// |    |         | \\\\\\\\\\\\\\\ |      +--| xxxxxxxxxx | \\ |
| ////////// |    |         | \\\\\\\\\\\\\\\ |      |  | xxxxxxxxxx | \\ |
-------------------         -------------------      V  -------------------
      CC = 0                      CC = 1             Color code = 8 or 4 = 12

------                      ------                      ------
| // | Color code = 8       | \\ | Color code = 4       | xx | Color code=12
------                      ------                      ------</code></pre>
<p><strong>Note:</strong></p>
<ol type="1">
<li>Conflicts are not detected when the pattern of the sprite whose CC
is “1” is piled on the portion CC=0 of the sprite which has a smaller
number and is nearest to it.</li>
<li>To display the sprite whose CC is “1”, CC bit of the sprite which
has smaller number should be set to 0.</li>
</ol>
<p>
 
</p>
<h4 id="judging-sprite-conflicts">5.3.3 Judging sprite conflicts</h4>
<p>A “conflict” in sprite mode 2 occurs when the display colour of a
sprite is not transparent and “1” bits on the line whose CC bit is 0
overlap each other. When two sprites conflict, bit 5 of S#0 becomes “1”
and the conflict can be detected (see <a
href="#figure-4.69-conflict-of-the-sprite-sprite-mode-2">Figure
4.69</a>). In this case, different from the sprite mode 1, the
coordinate where the conflict occurred can be detected by S#3 to S#6 as
shown in <a
href="#figure-4.70-readout-of-the-conflict-coordinate">Figure 4.70</a>.
Note that the coordinate which can be obtained by these registers is not
the coordinate where the conflict actually occurred. To get this, use <a
href="#expression-4.5-calculating-the-actual-conflict-coordinate">Expression
4.5</a>. S#3 to S#6 are reset when S#5 is read out.</p>
<h5 id="figure-4.69-conflict-of-the-sprite-sprite-mode-2"><em>Figure
4.69 Conflict of the sprite (sprite mode 2)</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
S#0     | .  | .  | X  | .  | .  | .  | .  | .  |
        -----------------------------------------
                    |    0: normal
                    +--&gt;
                         1: conflict occurred


        ----------------------------
        |                          |
        |  --------------------    |
        |  | \\\\\\\\\\\\\\\\ |    |
        |  | \\\\\\\\\\\\\\\\ |    |
        |  | \\\\\\\ ---------+----+-----------
        |  | \\\\\\\ | \\\\\\ |    |          |
        |  | \\\\\\\ | \\\\\\ |    |          |
        |  | \\\\\\\ | \\\\\\ |    |          |
        |  | \\\\\\\ | \\\\\\ |    |          |   the attribute of this line
        -  | \\\\\\\ | \ -----+----+--------  -     -------------------------
    +-- |  | \\\\\\\ | \ | xx | // | ///// |  | --&gt; |  | 0| 0|  :  :  :  :  |
    |   -  ----------+---+----- // | ///// |  -     -------------------------
    |   |            |   | /////// | ///// |  |        |     |
    |   -------------+---+---------- ///// |  |        +-----+
    |                |   | /////////////// |  |   CC and IC bits are both &quot;0&quot;
    | the attribute  |   -------------------  |
    | of this line   |                        |
    |                |                        |
    |                --------------------------
    V
-------------------------
|  | 0| 0|  :  :  :  :  |
-------------------------
   |     |
   +-----+
CC and IC bits are both &quot;0&quot;</code></pre>
<h5 id="figure-4.70-readout-of-the-conflict-coordinate"><em>Figure 4.70
Readout of the conflict coordinate</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        ----------------------------------------- --+
S#3     | X7 | X6 | X5 | X4 | X3 | X2 | X1 | X0 |   |
        -----------------------------------------   |
                                                    | X-coordinate where the conflict occurred
        -----------------------------------------   |
S#4     | 1  | 1  | 1  | 1  | 1  | 1  | 1  | X8 |   |
        ----------------------------------------- --+

        ----------------------------------------- --+
S#5     | Y7 | Y6 | Y5 | Y4 | Y3 | Y2 | Y1 | Y0 |   |
        -----------------------------------------   |
                                                    | Y-coordinate where the conflict occurred
        -----------------------------------------   |
S#6     | 1  | 1  | 1  | 1  | 1  | 1  | Y9 | Y8 |   |
        ----------------------------------------- --+</code></pre>
<h5
id="expression-4.5-calculating-the-actual-conflict-coordinate"><em>Expression
4.5 Calculating the actual conflict coordinate</em></h5>
<pre><code>    (X-coordinate where the conflict occurred) = (X-coordinate of S#3 and S#4) - 12
    (Y-coordinate where the conflict occurred) = (Y-coordinate of S#5 and S#6) - 8</code></pre>
<p>When more than nine sprites are placed on the same horizontal line,
bit 6 of S#0 becomes “1” and the number of the sprite plane whose order
of priority is 9 is entered to the 5 low order bits of S#0 (see <a
href="#figure-4.71-conflict-of-the-sprite-sprite-mode-2">Figure
4.71</a>).</p>
<h5 id="figure-4.71-conflict-of-the-sprite-sprite-mode-2"><em>Figure
4.71 Conflict of the sprite (sprite mode 2)</em></h5>
<pre><code>    MSB   7    6    5    4    3    2    1    0    LSB
        -----------------------------------------
S#0     | .  | X  | .  | X  | X  | X  | X  | X  |
        -----------------------------------------
               |       |                        |
               |       +------------------------+
               |     contains the 9th sprite number
               |
               |    0: normal
               +--&gt;
                    1: more than 9 sprites are occupying the same line</code></pre>
<h2 id="changes-from-the-original">Changes from the original:</h2>
<ul>
<li><p>In <a
href="#figure-4.3-indirect-access-to-rn-non-autoincrement-mode">Figure
4.3</a>, “Port#17” indication is corrected to “R#17”.</p></li>
<li><p>In <a
href="#figure-4.4-indirect-access-to-rn-autoincrement-mode">Figure
4.4</a>, “00” field in R#17 is corrected to “10”.</p></li>
<li><p>In <a href="#screen-structure-of-text-2">section 3.2.2</a>,
subsection <a href="#pattern-name-table-1">“Pattern name table”</a>,
text “12 low order bits o the address (A9 to A0)” is corrected to “12
low order bits of the address (A11 to A0)”</p></li>
<li><p>In <a
href="#figure-4.17-structure-of-text2-pattern-name-table">Figure
4.17</a>, the numerations of the two last rows in the Screen
correspondence table, originally “22” and “23”, are corrected to “25”
and “26” respectively.</p></li>
<li><p>In <a href="#screen-structure-of-text-2">section 3.2.2</a>,
subsection <a href="#blink-table">“Blink table”</a>, the text “the 9 low
order bits of the address (A9 to A0)” is corrected to “the 8 low order
bits of the address (A8 to A0)”.</p></li>
<li><p>In <a href="#figure-4.25-border-colour-specification">Figure
4.25</a>, indication “Specifies the value of the screen (0 to 15)” is
changed to “Specifies the border colour (0-15)”.</p></li>
<li><p>In <a
href="#figure-4.34-pattern-name-table-for-graphic-modes-2-and-3">Figure
4.34</a>, in the screen correspondance table, the three stages of the
screen are named “Upper stage of screen” in the original. This is
corrected, and the stages are named “Upper”, “Middle” and
“Lower”.</p></li>
<li><p>The title of <a href="#screen-colour-specification">section
3.6.3</a> is “Screen colour mode specification” in the original. The
word “mode” is erased.</p></li>
<li><p>In <a href="#pattern-name-table">section 3.8.2</a>, the text
“by writing the 2 high order bits” is corrected to “by writing the high
order bit”.</p></li>
<li><p>The title of <a
href="#figure-4.63-judging-the-conflict-sprite-mode-1">Figure 4.63</a>
is “Judging the conflict (sprite mode 2)” in the original. This is
corrected to “Judging the conflict (sprite mode 1)”.</p></li>
<li><p>In <a href="#figure-4.68-cc-bit-detection">Figure 4.68</a>,
indication “Color code = 8 or 4 or 12” is changed to “Color code = 8 or
4 = 12”.</p></li>
</ul>

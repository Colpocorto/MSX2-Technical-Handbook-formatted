<h1
id="chapter-5---access-to-peripherals-through-bios-section-7">CHAPTER 5
- ACCESS TO PERIPHERALS THROUGH BIOS (Section 7)</h1>
<p>
 
</p>
<h2 id="slots-and-cartridges">7. SLOTS AND CARTRIDGES</h2>
<p>The CPU (Z80) used in the MSX can access an address space of only 64K
bytes (0000H to FFFFH). MSX is set up to access an effective space of 1M
bytes. This is accomplished by using “slots”, which allocate more than
one memory byte or device to the same address.</p>
<p>This chapter introduces the use of the slot and information necessary
to connect the cartridge software or the new device to MSX via the
slot.</p>
<p>
 
</p>
<h2 id="index">Index</h2>
<p><a href="#slots-and-cartridges">7. SLOTS AND CARTRIDGES</a></p>
<p><a href="#slots">7.1 Slots</a></p>
<p><a href="#basic-slot-and-expansion-slot">7.1.1 Basic slot and
expansion slot</a></p>
<p><a href="#selecting-slots">7.1.2 Selecting slots</a></p>
<p><a href="#inter-slot-calls-calls-between-slots">7.2 Inter-slot
Calls (calls between slots)</a></p>
<p><a href="#inter-slot-call-operation">7.2.1 Inter-slot call
operation</a></p>
<p><a href="#inter-slot-call-use">7.2.2 Inter-slot call use</a></p>
<p><a href="#work-area-to-obtain-the-slot-status">7.2.3 Work area to
obtain the slot status</a></p>
<p><a href="#developing-cartridge-software">7.3 Developing Cartridge
Software</a></p>
<p><a href="#catridge-header">7.3.1 Catridge header</a></p>
<p><a href="#notes-on-the-creation-of-the-cartridge-software">7.3.2
notes on the creation of the cartridge software</a></p>
<p><a href="#changes-from-the-original">Changes from the
original</a></p>
<p>
 
</p>
<h3 id="slots">7.1 Slots</h3>
<p>A slot is an interface to effectively use a large address space, and
to interface any memory or devices connected to the MSX address bus
installed via the slot. The BASIC ROM inside the machine or RAM at
MSX-DOS mode are not exceptions. The place at which the cartridge
software is installed is also one of the slots. The following
descriptions introduce how the software and the devices are connected to
the slot.</p>
<p>
 
</p>
<h4 id="basic-slot-and-expansion-slot">7.1.1 Basic slot and expansion
slot</h4>
<p>The slot is either a basic slot or a expansion slot. A “basic slot”
is a slot directly connected to the CPU address bus, as shown in <a
href="#figure-5.36-basic-slot-and-expansion-slot">Figure 5.36</a>. The
standard MSX machine can have up to four basic slots. The basic slot can
be expanded up to four slots by connecting a slot expansion box (in some
cases, the expansion is already done inside the machine), and is called
“expansion slots”. When each of four basic slots is expanded to four
expansion slots, the maximum number of slots is 16. If you multiply 16
slots x 64K bytes you will get 1M bytes of accessible address space.</p>
<p>Note that the system itself cannot be started when expansion slot
boxes are connected to the expansion slot. So the user should only
connect expansion slot boxes to the basic slots. (Though the slot for
the standard MSX cartridge is always a basic slot, in some cases the
connector for the optional hardware of each machine might be connected
to the expansion slot).</p>
<h5 id="figure-5.36-basic-slot-and-expansion-slot"><em>Figure 5.36 Basic
slot and expansion slot</em></h5>
<pre><code>                                        ---------
                                        |       |
                                        |  CPU  |
                                        |       |
                                        |       |
                                        ---------
                                            |
                                            O
                                             \
                                               \
                                                 \
                                                   \
                    O               O               O               O
                    |               |               |               |
                ---------       ---------       ---------       ---------
                |       |       |       |       |       |       |       |
Basic slot      |       |       |       |       |       |       |       |
                |       |       |       |       |       |       |       |
                |       |       |       |       |       |       |       |
                ---------       ---------       ---------       ---------
                 Slot #0            O            Slot #2         Slot #3
                                  /
                                /
                              /
               O             O             O             O
               |             |             |             |
           ---------     ---------     ---------     ---------
           |       |     |       |     |       |     |       |
Expansion  |       |     |       |     |       |     |       |
slot       |       |     |       |     |       |     |       |
           |       |     |       |     |       |     |       |
           ---------     ---------     ---------     ---------
           Slot #1-0     Slot #1-1     Slot #1-2     Slot #1-3</code></pre>
<p>Each slot has 64K bytes from 0000H to FFFFH of address space and MSX
manages it by dividing it into four “pages” of 16K bytes each. The CPU
can select and access any slot for each page, and, as shown in <a
href="#figure-5.37-example-of-the-page-selection">Figure 5.37</a>, it is
possible to select and combine portions of several slots. Note that a
pages with a given page number cannot be assigned to a page with a
different page number (that is, page n of each slot is also page n to
the CPU).</p>
<h5 id="figure-5.37-example-of-the-page-selection"><em>Figure 5.37
Example of the page selection</em></h5>
<pre><code>        -------    -------    -------    -------                -------
Page 0  |  A  |    |  E  |    |  I  |    |  M  |  &lt;----------&gt;  |  A  |
        |-----|    |-----|    |-----|    |-----|                |-----|
Page 1  |  B  |    |  F  |    |  J  |    |  N  |  &lt;----------&gt;  |  J  |
        |-----|    |-----|    |-----|    |-----|                |-----|
Page 2  |  C  |    |  G  |    |  K  |    |  O  |  &lt;----------&gt;  |  G  |
        |-----|    |-----|    |-----|    |-----|                |-----|
Page 3  |  D  |    |  H  |    |  L  |    |  P  |  &lt;----------&gt;  |  H  |
        -------    -------    -------    -------                -------
         Slot 0     Slot 1     Slot 2     Slot 3              CPU address
                                                                 space</code></pre>
<p>
 
</p>
<h4 id="selecting-slots">7.1.2 Selecting slots</h4>
<p>Selecting slots is different for the basic slot than for the
expansion slot. For basic slots, it is done through the I/O port at A8H
(see <a href="#figure-5.38-selecting-the-basic-slot">Figure 5.38</a>),
and for expansion slots, it is done through the “expansion slot
selection register (FFFFH)” of the installed expansion slot (see <a
href="#figure-5.39-selecting-the-expansion-slot">Figure 5.39</a>). It is
not recommended to change them directly, so the user should not switch
the slots without careful planning. When the program switches the slot
of the page in which it resides, the action is not always predictable.
To call the program in another slot, use the inter-slot call described
in the next section.</p>
<h5 id="figure-5.38-selecting-the-basic-slot"><em>Figure 5.38 Selecting
the basic slot</em></h5>
<pre><code>             I/O port (A8H)
-----------------------------------------
|    :    |    :    |    :    |    :    |
-----------------------------------------
|         |         |         |         |
+---------+---------+---------+---------+
     |         |         |         |
     |         |         |         +---&gt; Basic slot number of page 0 (0 to 3)
     |         |         +-------------&gt; Basic slot number of page 1 (0 to 3)
     |         +-----------------------&gt; Basic slot number of page 2 (0 to 3)
     +---------------------------------&gt; Basic slot number of page 3 (0 to 3)</code></pre>
<h5 id="figure-5.39-selecting-the-expansion-slot"><em>Figure 5.39
Selecting the expansion slot</em></h5>
<pre><code>Expansion slot selection (FFFFH in expansion slot)
-----------------------------------------
|    :    |    :    |    :    |    :    |
-----------------------------------------
|         |         |         |         |
+---------+---------+---------+---------+
     |         |         |         |
     |         |         |         +---&gt; Expn. slot number of page 0 (0 to 3)
     |         |         +-------------&gt; Expn. slot number of page 1 (0 to 3)
     |         +-----------------------&gt; Expn. slot number of page 2 (0 to 3)
     +---------------------------------&gt; Expn. slot number of page 3 (0 to 3)</code></pre>
<p><strong>Note:</strong> to identify the kind of slot, in the case of
the expansion slot, the value written is read as the reversed value. The
value of this register is the same inside the basic slot.</p>
<p>The slot where MAIN-ROM or RAM is installed and the slot number of
the slot for the cartridge depend on the machine. Refer to the
appropriate manual to see how slots are used on your MSX. But the MSX
standard guarantees the normal operation no matter what is in the slots,
so it is not necessary to worry about the slot use, as long as you are
following the standard.</p>
<p>In some cases, however, it is required to know the slot number of the
specified software. For example, in the previous version, BASIC MAIN-ROM
was placed in basic slot #0 or in expansion slot #0-0 when basic slot #0
was expanded. So when MSX1 is upgraded to have the MSX2 functions by
installing MSX-VIDEO and BASIC ver 2.0 ROM, the MAIN ROM should be
placed somewhere other than slot #0 or slot #0-0. The slot where MSX2
SUB-ROM resides depends on the machine, but the information about the
slot where BASIC interpreter ROM resides can be obtained by referring to
the work area described below (the slot information can be obtained in
the format shown in <a href="#figure-5.40-format-for-the-slot">Figure
5.40</a>). When calling BIOS from DOS, examine the slot of MAIN-ROM in
this way.</p>
<ul>
<li><strong>EXPTBL (FCC1H, 1)</strong> - the slot of MAIN-ROM</li>
<li><strong>EXBRSA (FAF8H, 1)</strong> - the slot of SUB-ROM (0 for
MSX1)</li>
</ul>
<h5 id="figure-5.40-format-for-the-slot"><em>Figure 5.40 Format for the
slot</em></h5>
<pre><code>MSB                                   LSB
   7    6    5    4    3    2    1    0
-----------------------------------------
|    |    :    :    |    :    |    :    |
-----------------------------------------
|    |              |         |         |
+----+--------------+---------+---------+
  |       Unused         |         |
  |                      |         +---&gt; Basic slot number (0 to 3)
  |                      +-------------&gt; Expansion slot number (0 to 3)
  |
  +------------------------------------&gt; &quot;1&quot; if expansion slot</code></pre>
<p>When a given routine resides over page 1 and page 2 (4000H to BFFFH),
the same slot for page 2 as the one for page 1 should be selected when
the jump from page 1 to page 2 occurs within this routine. To do this,
you need to examine the slot, in page 1, where the program resides and
then to switch page 2 to that slot. To obtain information about the slot
where the program currently is, execute the program shown in <a
href="#list-5.11-program-to-know-the-current-slot">List 5.11</a>.</p>
<h5 id="list-5.11-program-to-know-the-current-slot"><em>List 5.11
Program to know the current slot</em></h5>
<pre><code>;********************************************************
;  List 5.11   to know where you are
;********************************************************
;       Suppose your program cartridge is 32K bytes
;       long (4000h..0BFFFH). You set the ID at 4000H
;       and 4001H and the execution start address within
;       page 1 (4000h..7FFFH), MSX passes control
;       to this address so the part which resides in
;       page 2 is not yet enabled at this point. You
;       have to know where you are (in what primary
;       slot, in what secondary slot) and enable the
;       part at page 2. Below is the sample program
;       to do this.
;
ENASLT  EQU     0024H           ;enable slot
RSLREG  EQU     0138H           ;read primary slot select register
EXPTBL  EQU     0FCC1H          ;slot is expanded or not

;----- program start -----

ENAP2:
        CALL    RSLREG          ;read primary slot #
        RRCA                    ;move it to bit 0,1 of [Acc]
        RRCA
        AND     00000011B
        LD      C,A
        LD      B,0
        LD      HL,EXPTBL       ;see if this slot is expanded or not
        ADD     HL,BC
        LD      C,A             ;save primary slot #
        LD      A,(HL)          ;See if the slot is expanded or not
        AND     80H
        OR      C               ;set MSB if so
        LD      C,A             ;save it to [C]
        INC     HL              ;Point to SLTTBL entry
        INC     HL
        INC     HL
        INC     HL
        LD      A,(HL)          ;Get what is currently output
                                ;to expansion slot register
        AND     00001100B
        OR      C               ;Finally form slot address
        LD      H,80H
        JP      ENASLT          ;enable page 2

        END</code></pre>
<p>
 
</p>
<h3 id="inter-slot-calls-calls-between-slots">7.2 Inter-slot Calls
(calls between slots)</h3>
<p>As described above, programs reside in different slots, so a program
not in the current slot might be needed in some cases. The most common
cases are listed below:</p>
<ol type="1">
<li><p>calling BIOS in MAIN-ROM from MSX-DOS level</p></li>
<li><p>calling BIOS in SUB-ROM from BASIC level (only the case of
MSX2)</p></li>
<li><p>calling BIOS in MAIN-ROM or SUB-ROM from cartridge
software</p></li>
</ol>
<p>In doing such calls, to switch slots easily and safely, there is a
group of BIOS routines called the inter-slot calls, which can be called
from the routine in any slot. This section describes the use of the
inter-slot calls.</p>
<p>
 
</p>
<h4 id="inter-slot-call-operation">7.2.1 Inter-slot call operation</h4>
<p>When calling BIOS in MAIN-ROM from MSX-DOS, the state of slots
changes as described below.</p>
<ol type="1">
<li><p>Since, in the initial MSX-DOS mode, RAM is selected all over 64K
address space, BASIC-ROM cannot be accessible in this state (see <a
href="#figure-5.41-inter-slot-call">Figure 5.41</a>-a).</p></li>
<li><p>To call BIOS in ROM, switch page 0 to MAIN-ROM or BASIC to
access. Then, call BIOS (see <a
href="#figure-5.41-inter-slot-call">Figure 5.41</a>-b).</p></li>
<li><p>Restore the original status after BIOS operations and return to
the initial address.</p></li>
</ol>
<h5 id="figure-5.41-inter-slot-call"><em>Figure 5.41 Inter-slot
call</em></h5>
<pre><code>a) When using MSX-DOS                     b) When calling BASIC-ROM BIOS

        MSX-DOS   BASIC-ROM                       MSX-DOS   BASIC-ROM
        -------    -------                        -------    -------
Page 0  | RAM |    | ROM |                Page 0  | RAM |    | ROM | BIOS is
        |-----|    |-----|                        |-----|    |-----| called
Page 1  | RAM |    | ROM |                Page 1  | RAM |    | ROM |
        |-----|    |-----|  &lt;----------&gt;          |-----|    |-----|
Page 2  | RAM |    | ___ |                Page 2  | RAM |    | ___ |
        |-----|    |-----|                        |-----|    |-----|
Page 3  | RAM |    | ___ |                Page 3  | RAM |    | ___ |
        -------    -------                        -------    -------
         Slot 3     Slot 0                         Slot 3     Slot 0</code></pre>
<p>This is easily done when the program resides in other than page 0,
but there can be some problem when the calling program resides in page 0
which is the same page as BIOS of the called program. Care is needed to
prevent the program from disappearing itself and generating
unpredictable results when it is switched to page 0. The inter-slot call
settles this problem by jumping to page 3 temporarily and then switching
slots.</p>
<p>
 
</p>
<h4 id="inter-slot-call-use">7.2.2 Inter-slot call use</h4>
<p>There are several ways to execute inter-slot calls, as described
below. They are included in MAIN-ROM as BIOS calls. Some of them are
offered in MSX-DOS, so inter-slot calls can be executed under
MSX-DOS.</p>
<p>
 
</p>
<p><em>(1) Inter-slot call routines in BIOS</em></p>
<h4
id="rdslt-000chmain---read-value-at-specified-address-of-specified-slot">RDSLT
(000CH/MAIN) - read value at specified address of specified slot</h4>
<ul>
<li><strong>Input</strong>:
<ul>
<li>A register ⟵ slot specification</li>
<li>HL register ⟵ address to be read at</li>
</ul></li>
<li><strong>Output</strong>: A register ⟵ value which has been read
out</li>
<li><strong>Use</strong>: AF, BC, DE</li>
<li><strong>Function</strong>: reads the value at the specified address
of the specified slot and stores it in the A register. The slot
specification is done using the A register in the form shown in <a
href="#figure-5.40-format-for-the-slot">Figure 5.40</a>. At this point,
when the objective slot is the basic slot, set “0” to the 6 high order
bits and define the slot #0 to #3 using the 2 low order bits. When
specifying the expansion slot, specify the basic slot by bit 0 and bit 1
and the expansion slot by bit 2 and bit 3 and set bit 7 to “1”.</li>
</ul>
<p>
 
</p>
<h4
id="wrslt-0014hmain---write-value-at-specified-address-of-specified-slot">WRSLT
(0014H/MAIN) - write value at specified address of specified slot</h4>
<ul>
<li><strong>Input</strong>:
<ul>
<li>A register ⟵ slot specification (same format as in Figure 5.40)</li>
<li>HL register ⟵ address to be written in</li>
<li>E register ⟵ data to be written</li>
</ul></li>
<li><strong>Output</strong>: —</li>
<li><strong>Use</strong>: AF, BC, D</li>
<li><strong>Function</strong>: writes E register value in the address
specified by HL register of the slot specified by the A register (the
specification format is the same as in <a
href="#figure-5.40-format-for-the-slot">Figure 5.40</a>).</li>
</ul>
<p>
 
</p>
<h4
id="calslt-001chmain---call-specified-address-of-specified-slot">CALSLT
(001CH/MAIN) - call specified address of specified slot</h4>
<ul>
<li><strong>Input</strong>:
<ul>
<li>8 high order bits of IY register ⟵ slot (same format as in <a
href="#figure-5.40-format-for-the-slot">Figure 5.40</a>)</li>
<li>IX register ⟵ address to be called</li>
</ul></li>
<li><strong>Output</strong>: depends on the result of the called
program</li>
<li><strong>Use</strong>: depends on the result of the called
program</li>
<li><strong>Function</strong>: calls the routine at the address
specified by IX register of the slot specified by the 8 high order bits
of IY register (the specification format is the same as in <a
href="#figure-5.40-format-for-the-slot">Figure 5.40</a>).</li>
</ul>
<p>
 
</p>
<h4 id="enaslt-0024hmain---swicth-slots">ENASLT (0024H/MAIN) - swicth
slots</h4>
<ul>
<li><strong>Input</strong>:
<ul>
<li>A register ⟵ slot (same format as in <a
href="#figure-5.40-format-for-the-slot">Figure 5.40</a>)</li>
<li>HL register ⟵ specifies the page to switch the slot by 2 high order
bits</li>
</ul></li>
<li><strong>Output</strong>: —</li>
<li><strong>Use</strong>: all</li>
<li><strong>Function</strong>: switches the page specified by the 2 high
order bits of the HL register to the slot specified by the A
register.</li>
</ul>
<p>
 
</p>
<h4
id="callf-0030hmain---call-specified-address-of-specified-slot">CALLF
(0030H/MAIN) - call specified address of specified slot</h4>
<ul>
<li><strong>Input</strong>: specifies the slot and the address in the
inline parameter format</li>
<li><strong>Output</strong>: depends on the result of the called
program</li>
<li><strong>Use</strong>: depends on the result of the called
program</li>
<li><strong>Function</strong>: calls the specified address of the
specified slot, but, different from CALSLT described above, the slot and
the address is specified in the inline parameter format, as described
below. That is, parameters are passet by one byte (same format as RDSLT)
to specify that the slot is placed just after the instruction which
calls CALLF and the next two bytes to specify the address are placed.
“CALL 0030H” may be replaced by the RST (restart) instruction, “RST
30H”. In this case, the inter-slot call is done in 4 bytes.</li>
</ul>
<h5 id="figure-5.42-example-of-the-inter-slot-call-execution"><em>Figure
5.42 Example of the inter-slot call execution</em></h5>
<pre><code>    RST     30H             ;interslot call
    DB      00000000B       ;select slot#0
    DW      006CH           ;call address = 006CH</code></pre>
<p>
 
</p>
<h4
id="rslreg-0138hmain---read-the-basic-slot-selection-register">RSLREG
(0138H/MAIN) - read the basic slot selection register</h4>
<ul>
<li><strong>Input</strong>: —</li>
<li><strong>Output</strong>: A register ⟵ value which has been read</li>
<li><strong>Use</strong>: —</li>
<li><strong>Function</strong>: reads the contents of the basic slot
selection register and stores it in the A register.</li>
</ul>
<p>
 
</p>
<h4
id="wslreg-013bhmain---write-in-the-basic-slot-selection-register">WSLREG
(013BH/MAIN) - write in the basic slot selection register</h4>
<ul>
<li><strong>Input</strong>: A register ⟵ value to be written</li>
<li><strong>Output</strong>: —</li>
<li><strong>Use</strong>: —</li>
<li><strong>Function</strong>: writes the A register value in the basic
slot selection register and selects the slot.</li>
</ul>
<p>
 
</p>
<h4 id="subrom-015chmain---call-specified-address-in-sub-rom">SUBROM
(015CH/MAIN) - call specified address in SUB-ROM</h4>
<ul>
<li><strong>Input</strong>: IX register ⟵ address to be called, PUSH IX
(see Appendix 2, SUB-ROM list)</li>
<li><strong>Output</strong>: depends on the result of the called
program</li>
<li><strong>Use</strong>: background register and IX, IY registers are
reserved</li>
<li><strong>Function</strong>: This is the routine to call BASIC SUB-ROM
especially. The slot where SUB-ROM resides is automatically examined.
Normally, EXTROM, described below, is used.</li>
</ul>
<p>
 
</p>
<h4 id="extrom-015fhmain---call-specified-address-in-sub-rom">EXTROM
(015FH/MAIN) - call specified address in SUB-ROM</h4>
<ul>
<li><strong>Input</strong>: IX register ⟵ address to be called</li>
<li><strong>Output</strong>: depends on the result of the called
program</li>
<li><strong>Use</strong>: background register and IY register are
reserved</li>
<li><strong>Function</strong>: This is the routine to call BASIC
SUB-ROM. The difference between this and SUB-ROM above is the point
whether the IX register value is pushed.</li>
</ul>
<p>
 
</p>
<p><em>(2) Inter-slot call in MSX-DOS</em></p>
<p>In MSX-DOS, five kinds of inter-slot calls are offered and their
entry addresses are defined at jump vectors of MSX-DOS. These are the
same as ones in BIOS, so refer to BIOS above for their functions or use.
Note that these routines should not be used when calling routines in
SUB-ROM from MSX-DOS.</p>
<ul>
<li>RDSLT (000CH) - read value at specified address of specified
slot</li>
<li>WRSLT (0014H) - write value at specified address of specified
slot</li>
<li>CALSLT (001CH) - call specified address of specified slot</li>
<li>ENASLT (0024H) - make specified slot available</li>
<li>CALLF (0030H) - call specified address of specified slot</li>
</ul>
<h5 id="list-5.12-calling-bios-from-msx-dos"><em>List 5.12 Calling BIOS
from MSX-DOS</em></h5>
<pre><code>;********************************************************
;  List 5.12    How to use BIOS from MSX-DOS.
;********************************************************
;
CALSLT  EQU     001CH           ;Inter slot call
EXBRSA  EQU     0FAF0H          ;Slot address of BIOS (main) ROM
EXPTBL  EQU     0FCC1H          ;Slot address of extended ROM
;
;       LD      IY,(EXPTBL-1)   ;Load slot address of the BIOS ROM
;                               ;in high byte of IY
;       LD      IX,address of the BIOS jump table
;       CALL    CALSLT
;
;----- Sample program to set text mode -----

INITXT  EQU     006CH
LINL40  EQU     0F3AEH
;
TOTEXT: LD      B,40
        LD      A,(EXBRSA)      ;slot address of SUB-ROM
        OR      A               ;0 if MSX1
        JR      Z,TO40
        LD      B,80

TO40:   LD      (LINL40),B      ;set width into work area
        LD      IX,INITXT
        LD      IY,(EXPTBL-1)   ;get expanded slot status to IYH
        CALL    CALSLT          ;perform an inter-slot call
        EI                      ;because CALSLT do DI
        RET

        END</code></pre>
<p>
 
</p>
<h4 id="work-area-to-obtain-the-slot-status">7.2.3 Work area to obtain
the slot status</h4>
<p>The following addresses involve the slot work area.</p>
<p>
 
</p>
<ul>
<li><strong>EXBRSA (FAF8H, 1)</strong> - SUB-ROM slot</li>
</ul>
<h5 id="figure-5.43-sub-rom-slot"><em>Figure 5.43 SUB-ROM slot</em></h5>
<pre><code>MSB                                   LSB
   7    6    5    4    3    2    1    0
-----------------------------------------
|    |    :    :    |    :    |    :    |
-----------------------------------------
|    |              |         |         |
+----+--------------+---------+---------+
  |       Unused         |         |
  |                      |         +---&gt; Basic slot number (0 to 3)
  |                      +-------------&gt; Expansion slot number (0 to 3)
  |
  +------------------------------------&gt; &quot;1&quot; if expansion slot</code></pre>
<p>
 
</p>
<ul>
<li><strong>EXPTBL (FCC1H, 4)</strong> - whether the basic slot is
expanded or not</li>
</ul>
<h5 id="figure-5.44-selecting-the-basic-slot"><em>Figure 5.44 Selecting
the basic slot</em></h5>
<pre><code>         MSB                                   LSB
            7    6    5    4    3    2    1    0
         -----------------------------------------
[FCC1H]  |    |    :    :    |    :    |    :    |  MAIN-ROM slot
         -----------------------------------------

         -----------------------------------------
[FCC2H]  |    |            Unused                |  Slot #1
         -----------------------------------------

         -----------------------------------------
[FCC3H]  |    |            Unused                |  Slot #2
         -----------------------------------------

         -----------------------------------------
[FCC4H]  |    |            Unused                |  Slot #3
         -----------------------------------------
           |
           +--&gt; 0: slot is not expanded
                1: slot is expanded</code></pre>
<p>
 
</p>
<ul>
<li><strong>SLTTBL (FCC5H, 4)</strong> - preservation area for the
expansion slot selection register value</li>
</ul>
<h5 id="figure-5.45-selecting-the-expansion-slot"><em>Figure 5.45
Selecting the expansion slot</em></h5>
<pre><code>         MSB                                   LSB
            7    6    5    4    3    2    1    0
         -----------------------------------------  expansion slot selection
[FCC5H]  |    :    |    :    |    :    |    :    |  register value of slot #0
         -----------------------------------------

         -----------------------------------------  expansion slot selection
[FCC6H]  |    :    |    :    |    :    |    :    |  register value of slot #1
         -----------------------------------------

         -----------------------------------------  expansion slot selection
[FCC7H]  |    :    |    :    |    :    |    :    |  register value of slot #2
         -----------------------------------------

         -----------------------------------------  expansion slot selection
[FCC8H]  |    :    |    :    |    :    |    :    |  register value of slot #3
         -----------------------------------------
         |         |         |         |         |
         +---------+---------+---------+---------+
              |         |         |         |
              |         |         |         +----&gt;  exp. slot num. for page 0
              |         |         +--------------&gt;  exp. slot num. for page 1
              |         +------------------------&gt;  exp. slot num. for page 2
              +----------------------------------&gt;  exp. slot num. for page 3</code></pre>
<p>
 
</p>
<ul>
<li><strong>SLTATR (FCC9H, 64)</strong> - test for existance of
application in each slot/page</li>
</ul>
<h5 id="figure-5.46-test-for-existence-of-application"><em>Figure 5.46
Test for existence of application</em></h5>
<pre><code>         -----------------------------------------
[FCC9H]  |    |    |    |         Unused         |  Slot #0-0, page 0
         |----+----+----+------------------------|
[FCCAH]  |    |    |    |         Unused         |  Slot #0-0, page 1
         |----+----+----+------------------------|
         |    |    |    |                        |
   .       .    .    .
   .       .    .    .
   .       .    .    .
         |    |    |    |                        |
         |----+----+----+------------------------|
[FD08H]  |    |    |    |         Unused         |  Slot #3-3, page 3
         -----------------------------------------
           |    |    |
           |    |    +--&gt;  Routine to process expanded statements  1:yes 0:no
           |    +-------&gt;  Routine to process expansion device     1:yes 0:no
           +------------&gt;  BASIC text                              1:yes 0:no</code></pre>
<p>The concrete work area for a given slot and page can be obtained with
the following expression:</p>
<pre><code>    SLTATR address = FCC9H + 16*basic slot + 4*expansion slot + page</code></pre>
<p>
 
</p>
<ul>
<li><strong>SLTWRK (FD09H, 128)</strong> - work area for
application</li>
</ul>
<h5 id="figure-5.47-work-area-for-application"><em>Figure 5.47 Work area
for application</em></h5>
<pre><code>         -----------------------------------------  Work area for
[FD09H]  |  ...................................  |  slot 0-0 page 0
         |---------------------------------------|
[FD0BH]  |  ...................................  |  Work area for
         |---------------------------------------|  slot 0-0 page 1
         |                                       |
   .     .                                       .
   .     .                                       .
   .     .                                       .
         |                                       |
         |---------------------------------------|  Work area for
[FD87H]  |  ...................................  |  slot 3-3 page 3
         -----------------------------------------</code></pre>
<p>The concrete work area for a given slot and page can be obtained with
the following expression:</p>
<pre><code>    SLTWRK address = FD09H + 32*basic slot + 8*expansion slot + 2*page</code></pre>
<p>
 
</p>
<h3 id="developing-cartridge-software">7.3 Developing Cartridge
Software</h3>
<p>MSX machines usually have at least one external slot and the hardware
to be put there is called a “cartridge”. There are cartridges such as
the ROM cartridges for application programs or games, input-output
device cartridges for a disk or RS-232 interface, RAM expansion
cartridges for expanding RAM, and slot expansion cartridges for
expanding slots. These cartridges make the MSX easy to upgrade. BASIC
and assembly language programs can also be stored in ROM cartridge
easily. This section describes how to develop cartridge software.</p>
<p>
 
</p>
<h4 id="catridge-header">7.3.1 Catridge header</h4>
<p>MSX cartridges have a 16-bye common header and, when the system is
reset, the cartridge is initialised by the information written in this
header. For ROM cartridges of BASIC or assembly language programs, they
can be automatically started by using the information written in the
header. <a href="#figure-5.48-program-cartridge-header">Figure 5.48</a>
shows the cartridge header configuration.</p>
<h5 id="figure-5.48-program-cartridge-header"><em>Figure 5.48 Program
cartridge header</em></h5>
<pre><code>        -------------------   4000H or 8000H
+0000H  |       ID        |
        |-----------------|
+0002H  |      INIT       |
        |-----------------|
+0004H  |    STATEMENT    |
        |-----------------|
+0006H  |     DEVICE      |
        |-----------------|
+0008H  |      TEXT       |
        |-----------------|
+000AH  |                 |
        |                 |
        |    Reserved     |   Note:  Reserved area should
        |                 |          be filled with 00H.
        |                 |
+0010H  -------------------</code></pre>
<h5 id="id">ID</h5>
<p>In the case of ROM cartridges, these two bytes have codes “AB” (41H,
42H). For SUB-ROM cartridges, the ID is “CD”.</p>
<h5 id="init">INIT</h5>
<p>When the cartridge is made to initialise the work area or I/O, these
two bytes are the addresses for the initialization routine; otherwise
0000H is assumed. After instructions such as getting the work area in
the initialization routine are placed, end with “RET”. All registers
except the SP register may be destroyed. For assembly language programs,
such as games, which loop within the cartridge, it is possible to
execute the object program from here.</p>
<h5 id="statement">STATEMENT</h5>
<p>When the cartridge is made to expand the CALL statement, these two
bytes are the address for the statement expansion routine; otherwise
0000H is assumed. If so, the statement expansion routine should reside
at 4000H to 7FFFH.</p>
<p>The CALL statement is described in the following format:</p>
<pre><code>    CALL &lt;expression statement name&gt; [(&lt;argument&gt;[, &lt;argument&gt;...])]</code></pre>
<p>The expression statement name can have up to 15 characters. As an
abbreviation for CALL, “_” (underscore) is available.</p>
<p>When the BASIC interpreter finds a CALL statement, it puts the
expansion statement name in PROCNM (FD89H, 16) in the work area and
passes the control to cartridges, whose contents of STATEMENT of the
header is other than 0, in the order from the one with the smaller slot
number. The HL register points to the text address next to the expansion
statement name at this point (see <a
href="#figure-5.49-input-output-of-the-operation-routine-of-the-expansion-statement">Figure
5.49</a>a).</p>
<h5
id="figure-5.49-input-output-of-the-operation-routine-of-the-expansion-statement"><em>Figure
5.49 Input-output of the operation routine of the expansion
statement</em></h5>
<pre><code>    ---------------------------------------------------------------------
    |                                                                   |
a)  |  Input setup when the interpreter calls routines to process       |
    |  expanded statements                                              |
    |                                                                   |
    |  CALL ABCDE(0,0,0):A=0                                            |
    |            ^                                                      |
    |            |                                                      |
    |            HL                                                     |
    |                                                                   |
    |  CY flag = 1                               +---- End of the name  |
    |                                            |     of the expanded  |
    |           -------------------------------------  statement        |
    |   PROCNM  |  A  |  B  |  C  |  D  |  E  | 00H |                   |
    |           -------------------------------------                   |
    |                                                                   |
    |-------------------------------------------------------------------|
    |                                                                   |
b)  |  Output setup when the expanded statement was not processed       |
    |                                                                   |
    |  CALL ABCDE(0,0,0):A=0                                            |
    |            ^                                                      |
    |            |                                                      |
    |            HL                                                     |
    |                                                                   |
    |  CY flag = 1                                                      |
    |                                                                   |
    |-------------------------------------------------------------------|
    |                                                                   |
c)  |  Output setup when the expanded statement was processed           |
    |                                                                   |
    |  CALL ABCDE(0,0,0):A=0                                            |
    |                   ^                                               |
    |                   |                                               |
    |                   HL                                              |
    |                                                                   |
    |  CY flag = 0                                                      |
    |                                                                   |
    ---------------------------------------------------------------------</code></pre>
<p>To develop the statement expansion routine, recognise the name of the
expansion statement written in PROCNM first, then return with setting
“1” to the carry flag without modifying the HL register if the statement
is not to be handled (see <a
href="#figure-5.49-input-output-of-the-operation-routine-of-the-expansion-statement">Figure
5.49</a>b); otherwise, handle it properly and set the HL register (text
pointer) to the next handled statement (where 00H or 3AH is placed
usually), then return after setting “0” to the carry flag (see <a
href="#figure-5.49-input-output-of-the-operation-routine-of-the-expansion-statement">Figure
5.49</a>c).</p>
<p>The BASIC interpreter determines the status of the carry flag whether
a CALL statement has been executed, and, if not, calls the next
cartridge. When all cartridges have not executed the statement (when the
carry flag has been “1” all the time), it displays “SYNTAX ERROR”. To
test arguments of the statement, it is convenient to use “internal
routines for the statement expansion” in <a
href="Chapter2.md#44-expansion-of-cmd-command">section 4.4 of chapter
2</a>.</p>
<h5 id="device">DEVICE</h5>
<p>These two bytes are the addresses of the device expansion routine,
when the cartridge does the device expansion (the input-output device
expansion); otherwise 0000H is used. When doing the device expansion,
the device expansion routine should be in 4000H-7FFFH. One cartridge can
have up to 4 devices. The name of the expansion device should be less
than 16 characters.</p>
<p>When the BASIC interpreter finds an undefined device, it stores that
in PROCNM (FD89H, 16) and put FFH in the A register and passes control
to the cartridge whose contents is not 0 in the order from the one with
the smaller slot number (see <a
href="#figure-5.50-input-output-to-the-device-expansion-routine">Figure
5.50</a>a).</p>
<p>When creating device expansion routines, identify the file descriptor
of PROCNM first, and, when it is not for the device to be processed,
return with setting 1 to the carry flag (see <a
href="#figure-5.50-input-output-to-the-device-expansion-routine">Figure
5.50</a>b). Otherwise, process it and set the device ID (0-3) in the A
register, then return with setting 0 to the carry flag (see <a
href="#figure-5.50-input-output-to-the-device-expansion-routine">Figure
5.50</a>c).</p>
<p>The BASIC interpreter determines by the status of the carry flag
whether or not it is processed, and, if not, call the next cartridge.
When all cartridges were not processed (that is, when the carry flag was
“1” all the time), “Bad file name ERROR” is displayed.</p>
<p>When the actual input-output operations are done, the BASIC
interpreter sets the device ID (0-3) in DEVICE (FD99H) and sets the
request to the device in the A register (see <a
href="#table-5.6-requests-to-the-device">Table 5.6</a>), then calls the
device expansion routine. The device expansion routine should refer to
it to handle the request.</p>
<h5
id="figure-5.50-input-output-to-the-device-expansion-routine"><em>Figure
5.50 Input-output to the device expansion routine</em></h5>
<pre><code>    ---------------------------------------------------------------------
    |                                                                   |
a)  |  Input setup when the interpreter calls routines to process       |
    |  the expanded device                                              |
    |                                                                   |
    |  OPEN &quot;ABC:&quot;...                                                   |
    |                                                                   |
    |  A register = FFH                                                 |
    |  CY flag = 1                   +---- End of the file descriptor   |
    |                                |                                  |
    |           -------------------------                               |
    |   PROCNM  |  A  |  B  |  C  | 00H |                               |
    |           -------------------------                               |
    |                                                                   |
    |-------------------------------------------------------------------|
    |                                                                   |
b)  |  Output setup when the expanded device was not processed          |
    |                                                                   |
    |  CY flag = 1                                                      |
    |                                                                   |
    |-------------------------------------------------------------------|
    |                                                                   |
c)  |  Output setup when the expanded device was processed              |
    |                                                                   |
    |  A register = device ID (0 to 3)                                  |
    |  CY flag = 0                                                      |
    |                                                                   |
    ---------------------------------------------------------------------</code></pre>
<h5 id="table-5.6-requests-to-the-device"><em>Table 5.6 Requests to the
device</em></h5>
<pre><code>--------------------------------------
|  Register A  |       Request       |
|--------------+---------------------|
|       0      |  OPEN               |
|--------------+---------------------|
|       2      |  CLOSE              |
|--------------+---------------------|
|       4      |  Random access      |
|--------------+---------------------|
|       6      |  Sequential output  |
|--------------+---------------------|
|       8      |  Sequential input   |
|--------------+---------------------|
|      10      |  LOC function       |
|--------------+---------------------|
|      12      |  LOF function       |
|--------------+---------------------|
|      14      |  EOF function       |
|--------------+---------------------|
|      16      |  FPOS function      |
|--------------+---------------------|
|      18      |  Backup character   |
--------------------------------------</code></pre>
<h5 id="text">TEXT</h5>
<p>These two bytes are text pointers of the BASIC program, when the
BASIC program in the cartridge would be auto-started (executed at
reset); otherwise they are 0000H. The size of the program must be under
16K bytes, 8000H to BFFFH.</p>
<p>The BASIC interpreter examines the contents of TEXT of the header
after the initialization (INIT) and after the system is started. When
they are not 0000H, it begins the execution from the address as BASIC
text pointer (see <a
href="#figure-5.51-executing-basic-program-cartridge">Figure 5.51</a>).
BASIC programs should be stored in the form of the intermediate code and
the beginning of it (the address pointed by TEXT) must be 00H, which
indicates the beginning of the program.</p>
<p>The execution speed of the program will be improved when the
objective line number of statements such as GOTO is the absolute address
of the objective text pointer.</p>
<h5 id="figure-5.51-executing-basic-program-cartridge"><em>Figure 5.51
Executing BASIC program cartridge</em></h5>
<pre><code>---------------------
|                   |  8000H
|-------------------|
|       TEXT        |----+
|-------------------|    |
|                   |    |
|                   |    |
|-------------------|&lt;---+
|                   |
|   BASIC program   |  The first byte must be 00H
|                   |
|-------------------|
|                   |
|                   |
|                   |
---------------------  BFFFH</code></pre>
<h5 id="how-to-place-basic-programs-in-rom">How to place BASIC programs
in ROM</h5>
<ol type="1">
<li>Change the starting address of BASIC text to 8021H.</li>
</ol>
<pre><code>    POKE &amp;HF676,&amp;H21 : POKE &amp;HF677,&amp;H80 : POKE &amp;H8020,0 : NEW</code></pre>
<p><em>Note:</em> these statements must be in one line.</p>
<ol start="2" type="1">
<li>Load the objective BASIC program.</li>
</ol>
<pre><code>    LOAD &quot;PROGRAM&quot;</code></pre>
<ol start="3" type="1">
<li>Create ID.</li>
</ol>
<pre><code>    AD = &amp;H8000
    FOR I = 0 TO 31    ----+
     POKE AD + I, 0        |  clears ID area
    NEXT I             ----+
    POKE &amp;H8000,ASC(&quot;A&quot;)
    POKE &amp;H8001,ASC(&quot;B&quot;)
    POKE &amp;H8008,&amp;H20
    POKE &amp;H8009,&amp;H80</code></pre>
<ol start="4" type="1">
<li>Put 8000H to BFFFH in ROM.</li>
</ol>
<p>
 
</p>
<h4 id="notes-on-the-creation-of-the-cartridge-software">7.3.2 notes on
the creation of the cartridge software</h4>
<p>In programs not requiring software from other cartridges (stand-alone
software such as games), the portion with the smaller address than the
work area used by BIOS (F380H) can be used freely.</p>
<p>But in programs which are executed by using BASIC interpreter
functions, the same area cannot be shared as the work area. To do this,
there are three methods:</p>
<ol type="1">
<li><p>Place RAM on the cartridge itself (the safest and most reliable
method).</p></li>
<li><p>When one or two bytes are needed for the work area, use two bytes
corresponding to itself in SLTWRK (FD09H to …) as the work
area.</p></li>
<li><p>When more than three bytes are needed for the work area,
allocates it from RAM used by BASIC. To do this, put the contents of
BOTTOM (FC48H) to the area corresponding to SLTWRK (FD09H to …), and
increase the value of BOTTOM by the needed work area, then allocate it
for the work area (see <a
href="#figure-5.52-allocating-the-work-area">Figure 5.52</a>).</p></li>
</ol>
<h5 id="figure-5.52-allocating-the-work-area"><em>Figure 5.52 Allocating
the work area</em></h5>
<pre><code>8000H   ----------------- &lt;-- (BOTTOM)     ----------------- &lt;-- (SLTWRK)
        |               |                  |   Work area   |
        |               |                  |---------------| &lt;-- (BOTTOM)
        |  User&#39;s area  |                  |               |
        |               |       ---&gt;       |  User&#39;s area  |
        |               |                  |               |
F380H   |---------------|                  |---------------|
        |  System work  |                  |  System work  |
FFFFH   -----------------                  -----------------</code></pre>
<p>See the following list for the reference of (2) and (3).</p>
<h5 id="list-5.13-example-of-allocating-the-work-area"><em>List 5.13
Example of allocating the work area</em></h5>
<pre><code>;********************************************************
;  List 5.13  subroutines to support slot
;              for ROM in 1 page
;********************************************************

RSLGREG EQU     0138H
EXPTBL  EQU     0FCC1H
BOTTOM  EQU     0FC48H
HIMEM   EQU     0FC4AH
SLTWRK  EQU     0FD09H

;--------------------------------------------------------
;
;       GTSL1   Get slot number of designated page
;       Entry   None
;       Return  A       Slot address as follows
;       Modify  Flags
;
;           FxxxSSPP
;           |   ||||
;           |   ||++-- primary slot # (0-3)
;           |   ++---- secondary slot # (0-3)
;           |          00 if not expanded
;           +--------- 1 if secondary slot # specified
;
;       This value can later be used as an input parameter
;       for the RDSLT, WRSLT, CALSLT, ENASLT and &#39;RST 10H&#39;
;
        PUBLIC  GTSL10
GETSL10:
        PUSH    HL              ;Save registers
        PUSH    DE

        CALL    RSLREG          ;read primary slot #
        RRCA
        RRCA
        AND     11B             ;[A]=000000PP
        LD      E,A
        LD      D,0             ;[DE]=000000PP
        LD      HL,EXPTBL
        ADD     HL,DE           :[HL]=EXPTBL+000000PP
        LD      E,A             ;[E]=000000PP
        LD      A,(HL)          ;A=(EXPTBL+000000PP)
        AND     80H             ;Use only MSB
        JR      Z,GTSL1NOEXP
        OR      E               ;[A]=F00000PP
        LD      E,A             ;save primary slot number
        INC     HL              ;point to SLTTBL entry
        INC     HL
        INC     HL
        INC     HL
        LD      A,(HL)          ;get current expansion slot register
        RRCA
        RRCA
        AND     11B             ;[A] = 000000SS
        RLCA
        RLCA                    ;[A] = 0000SS00
        OR      E               ;[A] = F000SSPP
;
GTSL1END:
        POP     DE
        POP     HL
        RET
GTSL1NOEXP:
        LD      A,E             ;[A] = 000000PP
        JR      GTSL1END


;--------------------------------------------------------
;
;       ASLW1   Get address of slot work
;       Entry   None
;       Return  HL      address of slot work
;       Modify  None
;
        PUBLIC  ASLW10
ASLW10:
        PUSH    DE
        PUSH    AF
        CALL    GTSL10          ;[A] = F000SSPP, SS = 00 if not expanded
        AND     00001111B       ;[A] = 0000SSPP
        LD      L,A             :[A] = 0000SSPP
        RLCA
        RLCA
        RLCA
        RLCA                    ;[A] = SSPP0000
        AND     00110000B       ;[A] = 00PP0000
        OR      L               ;[A] = 00PPSSPP
        AND     00111100B       ;[A] = 00PPSS00
        OR      01B             ;[A] = 00PPSSBB
;
;       Now, we have the sequence number for this cartridge
;       as follows.
;
;       00PPSSBB
;         ||||||
;         ||||++-- higher 2 bits of memory address (1)
;         ||++---- seconday slot # (0..3)
;         ++------ primary slot # (0..3)
;
        RLCA                    ;*=2
        LD      E,A
        LD      D,0             ;[DE] = 0PPSSBB0
        LD      HL,SLTWRK
        ADD     HL,DE
        POP     AF
        POP     DE
        RET


;--------------------------------------------------------
;
;       RSLW1   Read slot work
;       Entry   None
;       Return  HL      Content of slot work
;       Modify  None
;
        PUBLIC  RSLW10
RSLW10:
        PUSH    DE
        CALL    ASLW10          ;[HL] = address of slot work
        LD      E,(HL)
        INC     HL
        LD      D,(HL)          ;[DE] = (slot work)
        EX      DE,HL           ;[HL] = (slot work)
        POP     DE
        RET


;--------------------------------------------------------
;
;       WSLW1   Write slot work
;       Entry   HL      Data to write
;       Return  None
;       Modify  None
;
        PUBLIC  WSLW10
WSLW10:
        PUSH    DE
        EX      DE,HL           ;[DE] = data to write
        CALL    ASLW10          ;[HL] = address of slot work
        LD      (HL),E
        INC     HL
        LD      (HL),D
        EX      DE,HL           ;[HL] = data tow write
        POP     DE
        RET


;--------------------------------------------------------
;
; How to allocate work area for cartridges
; If the work area is greater than 2 bytes, make the SLTWRK point
; to the system variable BOTTOM (0FC48H), then update it by the
; amount of memory required. BOTTOM is set up by the initizalization
; code to point to the bottom of equipped RAM.
;
;          Ex, if the program is at 4000H..7FFFH.
;
;       WORKB   allocate work area from BOTTOM
;               (my slot work) &lt;- (old BOTTOM)
;       Entry   HL      required memory size
;       Return  HL      start address of my work area = old BOTTOM
;                       0 if cannot allocate
;       Modify  None
;
        PUBLIC  WORKB0
WORKB0:
        PUSH    DE
        PUSH    BC
        PUSH    AF

        EX      DE,HL           ;[DE] = Size
        LD      HL,(BOTTOM)     ;Get current RAM bottom
        CALL    WSLW10          ;Save BOTTOM to slot work
        PUSH    HL              ;Save old BOTTOM
        ADD     HL,DE           ;[HL] = (BOTTOM) + SIZE
        LD      A,H             ;Beyond 0DFFFH?
        CP      0E0H
        JR      NC,NOROOM       ;Yes, cannot allocate this much
        LD      (BOTTOM),HL     ;Updtae (BOTTOM)
        POP     HL              ;[HL] = old BOTTOM
WORKBEND:
        POP     AF
        POP     BC
        POP     DE
        RET
;
;       BOTTOM became greater than 0DFFFH, there is
;       no RAM to be allocated.
;
NOROOM:
        LD      HL,0
        CALL    WSLW10          ;Clear slot work
        JR      WORKBEND        ;Return 0 in [HL]

        END</code></pre>
<h5 id="hook">Hook</h5>
<p>The area called “hook” is used for expanding BASIC functions in FD9AH
to FFC9H of the work area used by MSX-BASIC. One hook has five bytes,
which are normally “RET”.</p>
<p>When MSX-BASIC does a certain operation (such as the one in the
description about the hook of the work area), it calls this hook from
there once. When the hook is “RET”, the control returns immediately; but
the function of BASIC can be expanded, when these five bytes were
re-written to do the inter-slot call to the program inside the cartridge
by the initialization routine (INIT) (see <a
href="#figure-5.53-setting-the-hook">Figure 5.53</a>).</p>
<p><a href="#list-5.14-using-the-hook">List 5.14</a> shows an example of
the program that the cartridge uses to hook H.KEYI for the timer
interrupt ptocess.</p>
<h5 id="figure-5.53-setting-the-hook"><em>Figure 5.53 Setting the
hook</em></h5>
<pre><code>BASIC internal routine     HOOK -----------------
          .             +-----&gt; |      RET      |
          .             |  +--- |---------------|
          .             |  |    |      RET      |
      CALL HOOK   ------+  |    |---------------|
          .       &lt;--------+    |      RET      |
          .                     |---------------|
          .                     |      RET      |
                                |---------------|
                                |      RET      |
                                -----------------

                                        |
                                        V
                                                  Interslot call
BASIC internal routine     HOOK ----------------- -----&gt; .
          .             +-----&gt; |    RST 30H    |        .
          .             |       |---------------|        .
          .             |       |  Slot number  |  Expanded process
      CALL HOOK   ------+       |---------------|        .
          .       &lt;-----+       |    Branch     |        .
          .             |       |-   address   -|        .
          .             |       |               |        .
                        |       |---------------|        .
                        +------ |      RET      | &lt;---- RET
                                -----------------</code></pre>
<h5 id="list-5.14-using-the-hook"><em>List 5.14 Using the hook</em></h5>
<pre><code>;********************************************************
;  List 5.14  Sample program to use HOOK
;********************************************************
;
; Start-up initialize entry
; This program will be called when system initializing.
;
H.KEYI  EQU     0FD9AH          ; interrupt hook
EXPTBL  EQU     0FCC1H          ; slots expanded or not
PSLTRG  EQU     0A8H            ; I/O port address of primary slot register
EXT     MYINT

INIT:
;       &lt;&lt;&lt; Please insert other initialization routine here, if you need. &gt;&gt;&gt;

; Set interrupt entry

        DI                      ; start of critical region

; Get old interrupt entry inter-slot call hook

        LD      DE,OLDINT       ; get address of old int. hook saved area
        LD      HL,H.KEYI       ; get address of interrupt entry hook
        LD      BC,5            ; lenght of hook is 5 bytes
        LDIR                    ; transfer

; Which slot address is this cartridge placed?

        CALL    GETMSLT         ; get my slot address

; Set new inter-slot call of interrupt entry

        LD      (H.KEYI+1),A    ; set slot address
        LD      A,0F7H          ; &#39;RST 30H&#39; inter-slot call operation code
        LD      (H.KEYI),A      ; set new hook op-code
        LD      HL,INTENT       ; get our interrupt entry point
        LD      (H.KEYI+2),HL   ; set new interrupt entry point
        LD      A,0C9H          ; &#39;RET&#39; operation code
        LD      (H.KEYI+4),A    ; set operation code of &#39;RET&#39;
        EI                      ; end of critical region
        RET


;--------------------------------------------------------
; Which slot address is the cartridge placed?
;  Entry: No
;  Action: Compute my slot address
;  Return: A = slot address
;  Modify: Flag

GTMSLT:
        PUSH    BC              ; save environment
        PUSH    HL
        IN      A,(PSLTRG)      ; read primary slot register
        RRCA                    ; move it to bit 0,1 of A
        RRCA
        AND     00000011B       ; get bit 1,0
        LD      C,A             ; set primary slot No.
        LD      B,0
        LD      HL,EXPTBL       ; see if the slot is expanded or not
        ADD     HL,BC
        OR      (HL)            ; set MSB if so
        LD      C,A
        INC     HL              ; point to SLTTBL entry
        INC     HL
        INC     HL
        INC     HL
        LD      A,(HL)          ; get what is currently output to
                                ; expansion slot register

        AND     00001100B       ; get bits 3,2
        OR      C               ; finally form slot address

        POP     HL              ; restore environment
        POP     BC
        RET                     ; return to main

;----- Interrupt entry -----

INTENT:
        CALL    MYINT           ; call interrupt handler
        JP      OLDINT          ; go to old interrupt handler

;----- HOOK save area -----

OLDINT: DS      5

        END</code></pre>
<h5 id="stack-pointer-initialisation">Stack pointer initialisation</h5>
<p>When MSX has an internal disk, sometimes the disk interface ROM does
the initialisation before the cartridge does, depending on the slot
location, and pushes down the stack pointer in the direction of the low
order address to allocate the work area. In this case, software not
using the disk should set the stack pointer again after the cartridge
received control; otherwise, the stack area might be exhausted and a
system crash might occur. Remember to initialise the stack pointer at
the beginning of the program.</p>
<h5 id="testing-the-performance-of-the-expansion-slot">Testing the
performance of the expansion slot</h5>
<p>When general software in the market is put in the expansion slot or
when RAM resides in the expansion slot, sometimes the application
program do not work. Since most MSX2 machines use the expansion slot
inside, problems may sometime result. Software to be sold in the market
should be thoroughly tested in both cases that it is put in the
expansion slot and that RAM resides in expansion slot.</p>
<p>Since the expansion slot register is placed in FFFFH, do not use it
as if it were RAM. For example, setting the stack in FFFFH using “LD SP,
0” in the program causes machines using the expansion slot to go out of
control.</p>
<h5 id="notes-on-calslt-use">Notes on CALSLT use</h5>
<p>Executing the inter-slot call in CALSLT and CALLF destroys the
contents of IX, IY, and the background processing register. When
returning from this routine, in MSX1 the interrupt is inhibited, but in
MSX2 the state before the call is restored.</p>
<p>When using CALSLT or CALLF to execute the inter-slot call, the
interrupt is always inhibited when calling the object program (see 2 in
the figure below) and when returning to the calling program (see 6
below).</p>
<pre><code>  Caller                Interslot call            Called

LD IY,SLOT                            (3)
                              +-----------------&gt; CALLME:
LD IX,CALLME                  |                    .
                   (1)        |(2)                 .
CALL CALSLT ------------------+                    .
                                      (4)          .
                              +------------------ RET
                   (6)        |(5)
            &lt;-----------------+</code></pre>
<p>In MSX2, the state of the interrupt is reserved before and after the
inter-slot call. That is, 3 in the figure is in the same state as 1, and
6 is in the same state as 4. Note when the called program executes “EI”
or “DI”.</p>
<h2 id="changes-from-the-original">Changes from the original</h2>
<ul>
<li><p>In description of <a
href="#subrom-015chmain---call-specified-address-in-sub-rom">SUBROM</a>
routine, comment “see page 352” has been changed to “see appendix
2…”</p></li>
<li><p>In description of SLTATR and SLTWRK <a
href="#work-area-to-obtain-the-slot-status">work areas</a>,
expressions for calculate the concrete work area for a given slot and
page have been added.</p></li>
<li><p>In the first line after beginning of <a
href="#work-area-to-obtain-the-slot-status">section 7.2.3</a>, “The
following routines…” has been corrected to “The following
addresses…”</p></li>
<li><p>In <a href="#figure-5.52-allocating-the-work-area">Figure
5.52</a>, indication of F380H address was placed in the middle of the
user’s area. It has been moved to the beginning of system work.</p></li>
</ul>
